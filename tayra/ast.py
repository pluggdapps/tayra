# -*- coding: utf-8 -*-

# This file is subject to the terms and conditions defined in
# file 'LICENSE', which is part of this source code package.
#       Copyright (c) 2011 R Pratap Chakravarthy

"""Module containing Node definition for all terminals and non-teminals nodes.

The AST tree is constructed according to the grammar. From the root
non-terminal use the children() method on every node to walk through the tree.

To walk throug the AST,
  * parse() the text, which returns the root non-terminal
  * Use children() method on every non-terminal node.
"""

# Gotcha : None
# Notes  : None
# Todo   : None

import sys, re

from   tayra.utils  import directive_tokens

# ------------------- AST Nodes (Terminal and Non-Terminal) -------------------

class Node( object ):

    def __init__( self, parser ):
        self.parser = parser
        self.parent = None

    def children( self ):
        """Tuple of childrens in the same order as parsed by the grammar rule.
        """
        return tuple()

    def validate( self ):
        """Validate this node and all the children nodes. Expected to be called
        before processing the nodes."""
        pass

    def headpass1( self, igen ):
        """Pre-processing phase 1, useful to implement multi-pass compilers"""
        [ x.headpass1( igen ) for x in self.children() ]

    def headpass2( self, igen ):
        """Pre-processing phase 2, useful to implement multi-pass compilers"""
        [ x.headpass2( igen ) for x in self.children() ]

    def generate( self, igen, *args, **kwargs ):
        """Code generation phase. The result must be an executable python
        script"""
        [ x.generate( igen, *args, **kwargs ) for x in self.children() ]

    def tailpass( self, igen ):
        """Post-processing phase 1, useful to implement multi-pass compilers"""
        [ x.tailpass( igen ) for x in self.children() ]

    def lstrip( self, chars ):
        """Strip the leftmost chars from the Terminal nodes. Each terminal node
        must return the remaining the characters.
        In case of the Non-terminal node, call all the children node's
        lstrip() method, until the caller recieves a non-empty return value.
        """
        pass

    def rstrip( self, chars ):
        """Strip the rightmost chars from the Terminal nodes. Each terminal
        node must return the remaining the characters.
        In case of the Non-terminal node, call all the children node's
        rstrip() method, until the caller recieves a non-empty return value.
        """
        pass

    def dump( self, context ):
        """Simply dump the contents of this node and its children node and
        return the same."""
        return ''.join([ x.dump(context) for x in self.children() ])

    def ismatched( self, context ):
        """This interface should return a boolean indicating whether the html
        generated by this node is matched. If a node expects that the html
        might be mismatched.
        After replacing etree with lxml mismatched elements are automatically
        taken care."""
        return True

    def show( self, buf=sys.stdout, offset=0, attrnames=False,
              showcoord=False ):
        """ Pretty print the Node and all its attributes and children
        (recursively) to a buffer.
            
        buf:   
            Open IO buffer into which the Node is printed.
        
        offset: 
            Initial offset (amount of leading spaces) 
        
        attrnames:
            True if you want to see the attribute names in name=value pairs.
            False to only see the values.
        
        showcoord:
            Do you want the coordinates of each Node to be displayed.
        """

    #---- Helper methods

    def stackcompute( self, igen, compute, astext=True ):
        """Push a new buf, execute the compute function, pop the buffer and
        append that to the parent buffer."""
        igen.pushbuf()
        compute()
        igen.popappend( astext=astext )
        return None

    def getroot( self ):
        """Get root node traversing backwards from this `self` node."""
        node = self
        parent = node.parent
        while parent : node, parent = parent, parent.parent
        return node

    def bubbleup( self, attrname, value ):
        """Bubble up value `value` to the root node and save that as its
        attribute `attrname`"""
        rootnode = self.getroot()
        setattr( rootnode, attrname, value )

    def bubbleupaccum( self, attrname, value, to=None ):
        """Same as bubbleup(), but instead of assigning the `value` to
        `attrname`, it is appended to the list."""
        rootnode = self.getroot()
        l = getattr( rootnode, attrname, [] )
        l.append( value )
        setattr( rootnode, attrname, l )

    @classmethod
    def setparent( cls, parnode, childnodes ):
        [ setattr( n, 'parent', parnode ) for n in childnodes ]


class Terminal( Node ) :
    """Abstract base class for Tayra Template's AST terminal nodes."""

    def __init__( self, parser, terminal='', **kwargs ):
        Node.__init__( self, parser )
        self.terminal = terminal
        [ setattr( self, k, v ) for k,v in kwargs.items() ]

    def __repr__( self ):
        return self.terminal

    def __str__( self ):
        return self.terminal

    def lstrip( self, chars ):
        """Strip off the leftmost characters from the terminal string. Return
        the remaining characters.
        """
        self.terminal = self.terminal.lstrip( chars )
        return self.terminal

    def rstrip( self, chars ):
        """Strip off the rightmost characters from the terminal string. Return
        the remaining characters.
        """
        self.terminal = self.terminal.rstrip( chars )
        return self.terminal

    def generate( self, igen, *args, **kwargs ):
        """Dump the content."""
        igen.puttext( self.dump(None) )

    def dump( self, context ):
        """Simply dump the contents of this node and its children node and
        return the same."""
        return self.terminal

    def show( self, buf=sys.stdout, offset=0, attrnames=False,
              showcoord=False ):
        """ Pretty print the Node and all its attributes and children
        (recursively) to a buffer.
            
        buf:   
            Open IO buffer into which the Node is printed.
        
        offset: 
            Initial offset (amount of leading spaces) 
        
        attrnames:
            True if you want to see the attribute names in name=value pairs.
            False to only see the values.
        
        showcoord:
            Do you want the coordinates of each Node to be displayed.
        """
        lead = ' ' * offset
        buf.write(lead + '%s: %r' % (self.__class__.__name__, self.terminal))
        buf.write('\n')


class NonTerminal( Node ):      # Non-terminal
    """Abstract base class for Tayra Template's AST non-terminalnodes."""

    def __init__( self, parser, *args, **kwargs ) :
        super().__init__( parser )
        self._terms = [ x for x in args if isinstance( x, Terminal ) ]
        self._nonterms = [ x for x in args if isinstance( x, NonTerminal ) ]

    def lstrip( self, chars ):
        """Strip off the leftmost characters from children nodes. Stop
        stripping on recieving non null string."""
        value = ''
        for c in self.children() :
            value = c.lstrip( chars )
            if value : break
        return value

    def rstrip( self, chars ):
        """Strip off the rightmost characters from children nodes. Stop
        stripping on recieving non null string."""
        value = ''
        children = list(self.children())
        children.reverse()
        for c in children :
            value = c.rstrip( chars )
            if value : break
        return value

    def gencontrolblock( self, igen, line, *args, **kwargs ):
        """Generate control blocks,
            if-elif-else, for and while loops.
        """
        igen.comment( line )
        igen.putstatement( line )
        if self.script :
            upindent,downindent = self.INDENT.dump(None),self.DEDENT.dump(None)
            igen.codeindent( up=upindent )
            if self.dirtyblocks :
                self.dirtyblocks.generate( igen, *args, **kwargs )
            self.script.generate( igen, *args, **kwargs )
            igen.codeindent( down=downindent )
        else :
            igen.putstatement('pass')
        return None

    def genfunction( self, igen, dline, fline, *args, **kwargs ):
        """Generate function block for 
            @function and @interface.
        """
        igen.cr()
        igen.comment( ('%s (with) %s' % (fline, dline)) if dline else fline )
        # function signature
        igen.putstatement( dline ) if dline else None
        igen.putstatement( fline )
        igen.codeindent( up='  ' )
        # function body
        if self.script :
            igen.pushbuf()
            kwargs['localfunc'] = True
            if self.dirtyblocks :
                self.dirtyblocks.generate( igen, *args, **kwargs )
            self.script.generate( igen, *args, **kwargs )
            kwargs.pop( 'localfunc' )
        else :
            igen.putstatement('pass')
        # return from function
        igen.flushtext()
        igen.popreturn( astext=True )
        igen.codeindent( down='  ' )
        return None

    def flatten( self, attrnode, attrs ):
        """Instead of recursing through left-recursive grammar, flatten them
        into sequential list for looping on them later."""
        node, rclist = self, []

        if isinstance(attrs, str) :
            fn = lambda n : [ getattr(n, attrs) ]
        elif isinstance(attrs, (list,tuple)) :
            fn = lambda n : [ getattr(n, attr) for attr in attrs ]
        else :
            fn = attrs

        while node :
            rclist.extend( filter( None, list(fn(node))) )
            node = getattr(node, attrnode)
        rclist.reverse()
        return rclist


# ------------------- Non-terminal classes ------------------------

class Template( NonTerminal ):
    """class to handle `template` grammar."""

    def __init__( self, parser, prolog, script ):
        super().__init__( parser, prolog, script )
        self.prolog, self.script = prolog, script
        # Set parent attribute for children, should be last statement !!
        self.setparent( self, self.children() )

        self.bodysignature = ''   # Will bubbleup during `headpass`
        self.implements = []        # [ (module, interface, pluginname), ...]
        self.interfaces = []        # [ (interface, methodname), ... ]
        self.htmlprologs = []       # [ html, html, ... ]

    def children( self ):
        return self._nonterms

    def headpass2( self, igen ):
        igen.initialize()
        super().headpass2( igen )

    def generate( self, igen, *args, **kwargs ):
        self.ttlhash = kwargs.pop( 'ttlhash', '' )
        self.ttlfile = self.parser.ttlparser.ttlfile

        # Prolog
        self.prolog.generate( igen, *args, **kwargs )

        # Generate the body function
        igen.cr()
        # Body function signature
        xs = [ self.bodysignature.strip(', \t'), '*args', '**kwargs' ]
        signature = ', '.join( filter( None, xs ))
        line = "def body( %s ) :" % signature
        igen.putstatement( line )
        igen.codeindent( up='  ' )
        igen.pushbuf()
        [ igen.puttext( html, force=True ) for html in self.htmlprologs ] 
        if self.script :
            # Body function's body
            self.script.generate( igen, *args, **kwargs )
        else :
            self.putstatement( 'pass' )
        # finish body function
        igen.flushtext()
        igen.popreturn( astext=True )
        igen.codeindent( down='  ' )

    def tailpass( self, igen ):
        igen.cr()
        igen.comment( "---- Global Functions", force=True )
        super().tailpass( igen )
        igen.comment( "---- Interface functions", force=True )
        if self.implements and self.interfaces :
            igen.implement_interface( self.implements, self.interfaces )
        igen.comment( "---- Footer", force=True )
        igen.footer( self.ttlhash, self.ttlfile )
        igen.finish()

    def show( self, buf=sys.stdout, offset=0, attrnames=False,
              showcoord=False ):
        lead = ' ' * offset
        buf.write( lead + '-->template: ' )
        if showcoord:
            buf.write( ' (at %s)' % self.coord )
        buf.write('\n')
        [x.show(buf, offset+5, attrnames, showcoord) for x in self.children()]


class Prolog( NonTerminal ):
    """class to handle `prolog` grammar."""

    def __init__( self, parser, prolog, nonterm ):
        super().__init__( parser, prolog, nonterm )
        self.prolog, self.nonterm = prolog, nonterm
        # Set parent attribute for children, should be last statement !!
        self.setparent( self, self.children() )

    def children( self ):
        return self._nonterms

    def headpass1( self, igen ):
        [ x.headpass1( igen ) for x in self.flatten( 'prolog', 'nonterm' ) ]

    def headpass2( self, igen ):
        [ x.headpass2( igen ) for x in self.flatten( 'prolog', 'nonterm' ) ]

    def generate( self, igen, *args, **kwargs ):
        [ x.generate( igen, *args, **kwargs ) 
                    for x in self.flatten( 'prolog', 'nonterm' ) ]

    def tailpass( self, igen ):
        [ x.tailpass( igen ) for x in self.flatten( 'prolog', 'nonterm' ) ]

    def show( self, buf=sys.stdout, offset=0, attrnames=False,
              showcoord=False ):
        if showcoord:
            buf.write( ' (at %s)' % self.coord )
        [x.show(buf, offset, attrnames, showcoord) for x in self.children()]


class DocType( NonTerminal ):
    """class to handle `doctype` grammar. Note that DTDs are deprecated in
    HTML5. We will have to wait and see how it evolves under HTML5."""

    dtdurls = {
      "html4.01transitional"    : (
            '<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN" '
            '"http://www.w3.org/TR/html4/loose.dtd">' ),

      "html4.01strict"          : (
            '<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01//EN" '
            '"http://www.w3.org/TR/html4/strict.dtd">' ),

      "html4.01frameset"        : (
            '<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Frameset//EN" '
            '"http://www.w3.org/TR/html4/frameset.dtd">' ),

      "xhtml1.0transitional"    : (
            '<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" '
            '"http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">' ),

      "xhtml1.0strict"          : (
            '<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" '
            '"http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd">' ),

      "xhtml1.0frameset"        : (
            '<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Frameset//EN" '
            '"http://www.w3.org/TR/xhtml1/DTD/xhtml1-frameset.dtd">' ),

      "xhtml1.1"                : (
            '<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.1//EN" '
            '"http://www.w3.org/TR/xhtml11/DTD/xhtml11.dtd">' ),

      "xhtml1.1basic"           : (
            '<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML Basic 1.1//EN" '
            '"http://www.w3.org/TR/xhtml-basic/xhtml-basic11.dtd">' ),

      "xhtml1.1mobile"          : (
          '<!DOCTYPE html PUBLIC "-//WAPFORUM//DTD XHTML Mobile 1.2//EN" '
          '"http://www.openmobilealliance.org/tech/DTD/xhtml-mobile12.dtd">' ),

      "xhtml+rdfa1.0"           : (
            '<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML+RDFa 1.0//EN" '
            '"http://www.w3.org/MarkUp/DTD/xhtml-rdfa-1.dtd">' ),

      "html"                    : '<!DOCTYPE html>',
    }

    def __init__( self, parser, directive, newlines ) :
        super().__init__( parser, directive, newlines )
        self.DIRECTIVE, self.NEWLINES = directive, newlines
        # Set parent attribute for children, should be last statement !!
        self.setparent( self, self.children() )

    def children( self ):
        return self._terms

    def headpass1( self, igen ):
        params = directive_tokens( self.DIRECTIVE.dump(None) )
        for param in params :
            dtd = self.dtdurls.get( param, '' )
            if dtd :
                dtd += self.NEWLINES.dump(None)
                self.bubbleupaccum( 'htmlprologs', dtd )
                break
        super().headpass1( igen )

    def generate( self, igen, *args, **kwargs ):
        pass

    def show( self, buf=sys.stdout, offset=0, attrnames=False,
              showcoord=False ):
        lead = ' ' * offset
        buf.write( lead + 'doctype: ' )
        if showcoord:
            buf.write( ' (at %s)' % self.coord )
        buf.write('\n')
        [x.show(buf, offset+2, attrnames, showcoord) for x in self.children()]


class Body( NonTerminal ):
    """class to handle ``body`` grammar."""

    def __init__( self, parser, directive, newlines ) :
        super().__init__( parser, directive, newlines )
        self.DIRECTIVE, self.NEWLINES = directive, newlines
        # Set parent attribute for children, should be last statement !!
        self.setparent( self, self.children() )

    def children( self ):
        return self._terms

    def headpass1( self, igen ):
        self.signature = self.DIRECTIVE.dump(None)[5:].strip(' \t\r\n')
        self.bubbleup( 'bodysignature', self.signature )
        super().headpass1( igen )

    def generate( self, igen, *args, **kwargs ):
        pass

    def show( self, buf=sys.stdout, offset=0, attrnames=False,
              showcoord=False ):
        lead = ' ' * offset
        buf.write( lead + 'body: ' )
        if showcoord:
            buf.write( ' (at %s)' % self.coord )
        buf.write('\n')
        [x.show(buf, offset+2, attrnames, showcoord) for x in self.children()]


class ImportAs( NonTerminal ):
    """class to handle `importas` grammar.
        @import .. [as ..]
    """

    def __init__( self, parser, directive, newlines ) :
        super().__init__( parser, directive, newlines )
        self.DIRECTIVE, self.NEWLINES = directive, newlines
        # Set parent attribute for children, should be last statement !!
        self.setparent( self, self.children() )

    def children( self ):
        return self._terms

    def headpass2( self, igen ):
        parts = filter( None, 
                        self.DIRECTIVE.dump(None).strip(' \t\r\n').split(' ') )
        if parts[1].endswith('.ttl') and parts[2] == 'as' :
            ttlfile, modname = parts[1], parts[3]
        else :
            ttlfile = parts[1]
        igen.putimport( ttlfile )
        super().headpass2( igen )

    def generate( self, igen, *args, **kwargs ):
        pass

    def show( self, buf=sys.stdout, offset=0, attrnames=False,
              showcoord=False ):
        lead = ' ' * offset
        buf.write( lead + 'importas: ' )
        if showcoord:
            buf.write( ' (at %s)' % self.coord )
        buf.write('\n')
        [x.show(buf, offset+2, attrnames, showcoord) for x in self.children()]


class Inherit( NonTerminal ):
    """class to handle `inherit` grammar."""

    def __init__( self, parser, directive, newlines ) :
        super().__init__( parser, directive, newlines )
        self.DIRECTIVE, self.NEWLINES = directive, newlines
        # Set parent attribute for children, should be last statement !!
        self.setparent( self, self.children() )

    def children( self ):
        return self._terms

    def headpass2( self, igen ):
        line = filter( None,
                       self.DIRECTIVE.dump(None).strip(' \t\r\n').split(' ') )
        igen.putinherit( parts[1] )
        super().headpass2( self, igen )

    def generate( self, igen, *args, **kwargs ):
        pass

    def show( self, buf=sys.stdout, offset=0, attrnames=False,
              showcoord=False ):
        lead = ' ' * offset
        buf.write( lead + 'inherit: ' )
        if showcoord:
            buf.write( ' (at %s)' % self.coord )
        buf.write('\n')
        [x.show(buf, offset+2, attrnames, showcoord) for x in self.children()]


class Implement( NonTerminal ):
    """class to handle `implement` grammar."""

    def __init__( self, parser, directive, newlines ) :
        super().__init__( parser, directive, newlines )
        self.DIRECTIVE, self.NEWLINES = directive, newlines
        # Set parent attribute for children, should be last statement !!
        self.setparent( self, self.children() )

    def children( self ):
        return self._terms

    def headpass1( self, igen ):
        parts = [ x.strip() for x in 
                  self.DIRECTIVE.dump(None).strip(' \t\r\n').split(' ') ]
        assert parts[2] == 'as'
        module, interfacename = parts[1].split(':', 1)
        self.bubbleupaccum( 'implements', (module, interfacename, parts[3]) )
        super().headpass1( igen )

    def generate( self, igen, *args, **kwargs ):
        pass

    def show( self, buf=sys.stdout, offset=0, attrnames=False,
              showcoord=False ):
        lead = ' ' * offset
        buf.write( lead + 'implement: ' )
        if showcoord:
            buf.write( ' (at %s)' % self.coord )
        buf.write('\n')
        [x.show(buf, offset+2, attrnames, showcoord) for x in self.children()]


class Use( NonTerminal ):
    """class to handle `use` grammar."""

    def __init__( self, parser, directive, newlines ) :
        super().__init__( parser, directive, newlines )
        self.DIRECTIVE, self.NEWLINES  = directive, newlines
        # Set parent attribute for children, should be last statement !!
        self.setparent( self, self.children() )

    def _parseline( self, line ):
        # TODO : Broken !! Fix this
        parts = list( filter( None, map(
            lambda x : x [0],
            re.findall( r'((\$\{.+\})|([^ \r\n\f\t]+))(?=[ \t]|$)', line )
        )))
        if len(parts) == 5 and (parts[0], parts[3]) == ('@use', 'as') :
            interface, pluginname, importname = parts[1], parts[2], parts[4]
        elif len(parts) == 4 and (parts[0], parts[2]) == ('@use', 'as') :
            interface, pluginname, importname = parts[1], '', parts[3]
        else :
            raise Exception( '@use directive syntax error' )
        module, interfacename = interface.split(':')
        match = re.match( r'\$\{(.+)\}', pluginname )
        if match :
            text, filters = ExprsContents.parseexprs( match.groups()[0] )
            pluginname = text, filters
        return module, interfacename, pluginname, importname

    def children( self ):
        return self._terms

    def headpass2( self, igen ):
        line = self.USE.dump(None).strip(' \t\r\n')
        self.module, self.interfacename, self.pluginname, self.name = \
                self._parseline( line )
        igen.useinterface(
                self.module, self.interfacename, self.pluginname, self.name )
        super().headpass2( igen )

    def generate( self, igen, *args, **kwargs ):
        pass

    def show( self, buf=sys.stdout, offset=0, attrnames=False,
              showcoord=False ):
        lead = ' ' * offset
        buf.write( lead + 'use: ' )
        if showcoord:
            buf.write( ' (at %s)' % self.coord )
        buf.write('\n')
        [x.show(buf, offset+2, attrnames, showcoord) for x in self.children()]


class Script( NonTerminal ):
    """class to handle `script` grammar."""

    def __init__( self, parser, script, nonterm ) :
        super().__init__( self, parser, script, nonterm )
        self.script, self.nonterm = script, nonterm
        # Set parent attribute for children, should be last statement !!
        self.setparent( self, self.children() )

    def children( self ):
        return self._nonterms

    def headpass1( self, igen ):
        [ x.headpass1( igen ) for x in self.flatten( 'script', 'nonterm' ) ]

    def headpass2( self, igen ):
        [ x.headpass2( igen ) for x in self.flatten( 'script', 'nonterm' ) ]

    def generate( self, igen, *args, **kwargs ):
        [ x.generate( igen, *args, **kwargs ) 
                    for x in self.flatten( 'script', 'nonterm' ) ]

    def tailpass( self, igen ):
        [ x.tailpass( igen ) for x in self.flatten( 'script', 'nonterm' ) ]

    def show( self, buf=sys.stdout, offset=0, attrnames=False,
              showcoord=False ):
        if showcoord:
            buf.write( ' (at %s)' % self.coord )
        [x.show(buf, offset, attrnames, showcoord) for x in self.children()]


class CommentLine( NonTerminal ):
    """class to handle `commentline` grammar."""

    def __init__( self, parser, line, newlines ) :
        super().__init__( parser, line, newlines )
        self.COMMENTLINE, self.NEWLINES = line, newlines
        # Set parent attribute for children, should be last statement !!
        self.setparent( self, self.children() )

    def children( self ):
        return self._terms

    def generate( self, igen, *args, **kwargs ):
        pass

    def show( self, buf=sys.stdout, offset=0, attrnames=False,
              showcoord=False ):
        lead = ' ' * offset
        buf.write( lead + 'commentline: ' )
        if showcoord:
            buf.write( ' (at %s)' % self.coord )
        buf.write('\n')
        [x.show(buf, offset+2, attrnames, showcoord) for x in self.children()]


class CommentBlock( NonTerminal ):
    """class to handle `commentblock` grammar."""

    def __init__( self, parser, commentopen, commenttext, commentclose, nl ) :
        super().__init__( parser, commentopen, commenttext, commentclose, nl )
        self.COMMENTOPEN, self.COMMENTTEXT, self.COMMENTCLOSE, self.NEWLINES=\
                commentopen, commenttext, commentclose, nl
        # Set parent attribute for children, should be last statement !!
        self.setparent( self, self.children() )

    def children( self ):
        return self._terms

    def headpass1( self, igen, *args, **kwargs ):
        if isinstance( self.parent, Prolog ):
            self.bubbleupaccum( 'htmlprologs', self.dump(None) )

    def generate( self, igen, *args, **kwargs ):
        if isinstance( self.parent, Prolog ):
            pass

    def show( self, buf=sys.stdout, offset=0, attrnames=False,
              showcoord=False ):
        lead = ' ' * offset
        buf.write( lead + 'commentblock: ' )
        if showcoord:
            buf.write( ' (at %s)' % self.coord )
        buf.write('\n')
        [x.show(buf, offset+2, attrnames, showcoord) for x in self.children()]


class Statement( NonTerminal ):
    """class to handle `statement` grammar."""

    def __init__( self, parser, statement, newlines ) :
        super().__init__( parser, statement, newlines )
        self.STATEMENT, self.NEWLINES = statement, newlines
        # Set parent attribute for children, should be last statement !!
        self.setparent( self, self.children() )

    def children( self ):
        return self._terms

    def generate( self, igen, *args, **kwargs ):
        igen.putstatement( self.STATEMENT.dump(None).lstrip('@ \t') )

    def show( self, buf=sys.stdout, offset=0, attrnames=False,
              showcoord=False ):
        lead = ' ' * offset
        buf.write( lead + 'statement: ' )
        if showcoord:
            buf.write( ' (at %s)' % self.coord )
        buf.write('\n')
        [x.show(buf, offset+2, attrnames, showcoord) for x in self.children()]


class TagLine( NonTerminal ):
    """class to handle `tagline` grammar."""

    def __init__( self, parser, tagbegin, text, newlines ) :
        super().__init__( parser, tagbegin, text, newlines )
        self.TAGBEGIN, self.TEXT, self.NEWLINES = tagbegin, text, newlines
        # Set parent attribute for children, should be last statement !!
        self.setparent( self, self.children() )

    def children( self ):
        return self._terms

    def generate( self, igen, *args, **kwargs ):
        from  tayra.lexer import TTLLexer
        # TAGBEGIN
        tagbegin = self.TAGBEGIN.dump(None).strip(' \t')
        igen.pushbuf()
        s = 0
        for m in re.finditer( TTLLexer.exprsubst, tagbegin ) :
            expr = m.group()
            start, end = m.regs
            igen.puttext( tagbegin[s:start] )
            igen.evalexprs( expr[2:-1] )
            s = end
        igen.puttext( tagbegin[s:] ) if tagbegin[s:] else None
        igen.pushbuf()
        self.TEXT.generate( igen, *args, **kwargs ) if self.TEXT else None
        self.NEWLINES.generate( igen, *args, **kwargs )
        if not isinstance( self.parent, TagBlock ):
            igen.handletag()
         
    def show( self, buf=sys.stdout, offset=0, attrnames=False,
              showcoord=False ):
        lead = ' ' * offset
        buf.write( lead + 'tagline: ' )
        if showcoord:
            buf.write( ' (at %s)' % self.coord )
        buf.write('\n')
        [x.show(buf, offset+2, attrnames, showcoord) for x in self.children()]


class TagBlock( NonTerminal ):
    """class to handle `tagblock` grammar."""

    def __init__( self, parser, tagline, indent, script, dedent ) :
        super().__init__( parser, tagline, indent, script, dedent )
        self.tagline, self.INDENT, self.script, self.DEDENT = \
                tagline, indent, script, dedent
        # Set parent attribute for children, should be last statement !!
        self.setparent( self, self.children() )

    def children( self ):
        return filter( None, 
                       (self.tagline, self.INDENT, self.script, self.DEDENT) )

    def generate( self, igen, *args, **kwargs ):
        super().generate( igen, *args, **kwargs )
        igen.handletag()

    def show( self, buf=sys.stdout, offset=0, attrnames=False,
              showcoord=False ):
        lead = ' ' * offset
        buf.write( lead + 'tagblock: ' )
        if showcoord:
            buf.write( ' (at %s)' % self.coord )
        buf.write('\n')
        [x.show(buf, offset+2, attrnames, showcoord) for x in self.children()]


class TextBlock( NonTerminal ):
    """class to handle `textblock` grammar."""

    def __init__( self, parser, tb, text, newlines, indent, script, dedent ):
        super().__init__( parser, tb, text, newlines, indent, script, dedent )
        self.tb, self.TEXT, self.NEWLINES = tb, text, newlines
        self.INDENT, self.script, self.DEDENT = indent, script, dedent
        # Set parent attribute for children, should be last statement !!
        self.setparent( self, self.children() )

    def children( self ):
        x = ( self.tb, self.TEXT, self.NEWLINES, self.INDENT, self.script,
              self.DEDENT )
        return filter( None, x )

    def generate_TEXT( self, text, igen ):
        from  tayra.lexer import TTLLexer
        s = 0
        for m in re.finditer( TTLLexer.exprsubst, text ) :
            expr = m.group()
            start, end = m.regs
            igen.puttext( text[s:start] )
            igen.evalexprs( expr[2:-1] )
            s = end
        igen.puttext( text[s:] ) if text[s:] else None

    def generate( self, igen, *args, **kwargs ):
        # Textblock
        self.tb.generate( igen, *args, **kwargs ) if self.tb else None
        # TEXT
        text = self.TEXT.dump(None).strip(' \t')
        self.generate_TEXT( text, igen ) if text else None
        # NEWLINE
        self.NEWLINES.generate( igen, *args, **kwargs ) \
                                        if self.NEWLINES else None
        # Nested script.
        cs = filter( None, (self.INDENT,self.script,self.DEDENT) )
        [ c.generate( igen, *args, **kwargs ) for c in cs ]

    def show( self, buf=sys.stdout, offset=0, attrnames=False,
              showcoord=False ):
        if showcoord:
            buf.write( ' (at %s)' % self.coord )
        [x.show(buf, offset, attrnames, showcoord) for x in self.children()]


class InterfaceBlock( NonTerminal ):
    """class to handle `interfaceblock` grammar."""

    def __init__( self,parser,interface,dirtyblocks,indent,script,dedent ) :
        NonTerminal.__init__(
            self, parser, interface, dirtyblocks, indent, script, dedent )
        self._terms = self.INTERFACE, self.INDENT, self.DEDENT = \
                interface, indent, dedent
        self._nonterms = self.dirtyblocks,self.script = dirtyblocks,script
        self._terms = filter( None, self._terms )
        self._nonterms = filter( None, self._nonterms )
        # Set parent attribute for children, should be last statement !!
        self.setparent( self, self.children() )

    def children( self ):
        x = ( self.INTERFACE, self.dirtyblocks, self.INDENT, self.script,
              self.DEDENT )
        return filter(None, x)

    def _parseline( self, line ):
        interface, signature = line.strip().split('(', 1)
        signature = '(' + signature
        interfacename, methodname = interface.rsplit('.', 1)
        funcline = 'def ' + methodname + signature
        return interfacename, methodname, funcline

    def headpass1( self, igen ):
        line = ' '.join( self.INTERFACE.dump(None)[10:].splitlines() )
        self.interfacename, self.methodname, self.funcline = \
                self._parseline( line )
        self.bubbleupaccum( 
                'interfaces', (self.interfacename, self.methodname) )
        NonTerminal.headpass1( self, igen )

    def generate( self, igen, *args, **kwargs ):
        self.args, self.kwargs = args, kwargs

    def tailpass( self, igen ):
        self.genfunction( 
                igen, None, self.funcline, *self.args, **self.kwargs )
        # Do tail pass after the deferred generation.
        NonTerminal.tailpass( self, igen )

    def dump( self, context ) :
        text = self.INTERFACE.dump(context)
        text += self.dirtyblocks and self.dirtyblocks.dump(context) or ''
        context.htmlindent += self.INDENT.dump(context)
        text += self.script.dump(context)
        context.htmlindent = context.htmlindent[:-len(self.DEDENT.terminal)]
        return text

    def show( self, buf=sys.stdout, offset=0, attrnames=False,
              showcoord=False ):
        lead = ' ' * offset
        buf.write( lead + 'interfaceblock: ' )
        if showcoord:
            buf.write( ' (at %s)' % self.coord )
        buf.write('\n')
        [x.show(buf, offset+2, attrnames, showcoord) for x in self.children()]

class FunctionBlock( NonTerminal ):
    """class to handle `functionblock` grammar."""

    def __init__( self, parser, decorator, function, dirtyblocks, indent,
                  script, dedent ):
        NonTerminal.__init__( self, parser, decorator, function, indent,
                              script, dedent )
        self._terms = \
                self.DECORATOR, self.FUNCTION, self.INDENT, self.DEDENT = \
                    decorator, function, indent, dedent
        self._nonterms = self.dirtyblocks, self.script = dirtyblocks, script
        self._nonterms = filter( None, self._nonterms )
        # Set parent attribute for children, should be last statement !!
        self.setparent( self, self.children() )

    def children( self ):
        x = ( self.DECORATOR, self.FUNCTION, self.dirtyblocks, self.INDENT,
              self.script, self.DEDENT )
        return filter( None, x )

    re_dec = re.compile( '@dec[ \t]+([^(]+)\(([^)]*)\)' )
    def headpass1( self, igen ):
        # Function signature
        fline = self.FUNCTION.dump(None)
        self.fline = \
                ' '.join( fline.replace( '@function', 'def' ).splitlines() )
        self.dline = ''
        if self.DECORATOR :
            f = self.re_dec.findall( self.DECORATOR.dump(None) )
            fnname, argstr = f[0] if f and f[0] else (None, None)
            self.dline = ('@%s('%fnname) + ( argstr + ', ' if argstr else '' )
            self.dline += '_ttlcontext=_ttlcontext )'
        NonTerminal.headpass1( self, igen )

    def generate( self, igen, *args, **kwargs ):
        self.localfunc = kwargs.get( 'localfunc', False )
        self.args, self.kwargs = args, kwargs
        if self.localfunc :
            # Function block, script will be generated via genfunction.
            self.genfunction( igen, self.dline, self.fline,
                              *self.args, **self.kwargs )

    def tailpass( self, igen ):
        if self.localfunc == False :
            # Function block, script will be generated via genfunction
            self.genfunction( igen, self.dline, self.fline,
                              *self.args, **self.kwargs )
        # Do tail pass after the deferred generation.
        NonTerminal.tailpass( self, igen )

    def dump( self, context ) :
        text = self.DECORATOR.dump(context)
        text += self.FUNCTION.dump(context)
        text += self.dirtyblocks and self.dirtyblocks.dump(context) or ''
        context.htmlindent += self.INDENT.dump(context)
        text += self.script.dump(context)
        context.htmlindent = context.htmlindent[:-len(self.DEDENT.terminal)]
        return text

    def show( self, buf=sys.stdout, offset=0, attrnames=False,
              showcoord=False ):
        lead = ' ' * offset
        buf.write( lead + 'functionblock: ' )
        if showcoord:
            buf.write( ' (at %s)' % self.coord )
        buf.write('\n')
        [x.show(buf, offset+2, attrnames, showcoord) for x in self.children()]


class FilterBlock( NonTerminal ):
    """class to handle `filterblock` grammar."""

    def __init__(self, parser, filteropen, nl1, filtertext, filterclose, nl2):
        super().__init__(parser,filteropen,nl1,filtertext,filterclose,nl2 )
        self.FILTEROPEN, self.filtertext, self.FILTERCLOSE = \
                filteropen, filtertext, filterclose
        self.NEWLINES1, self.NEWLINES2 = nl1, nl2
        name = filteropen[1:].split(':', 1)[0]
        self.plugin = parser.ttlparser.compiler.query_plugin( 
                        ITayraFilterBlock, name )
        # Set parent attribute for children, should be last statement !!
        self.setparent( self, self.children() )

    def children( self ):
        x = ( self.FILTEROPEN, self.NEWLINES1, self.filtertext,
              self.FILTERCLOSE, self.NEWLINES2 )
        return filter( None, x )

    def headpass1( self, igen ):
        self.passresult = self.plugin.headpass1( igen,
                                       self.FILTEROPEN.dump(None),
                                       self.FILTERTEXT.dump(None),
                                       self.FILTERCLOSE.dump(None) )

    def headpass1( self, igen ):
        self.passresult = self.plugin.headpass2( igen, self.passresult )

    def generate( self, igen, *args, **kwargs ):
        self.passresult = self.plugin.headpass2(
                                igen, self.passresult, *args, **kwargs )

    def tailpass( self, igen ):
        self.passresult = self.plugin.tailpass( igen, self.passresult )

    def show( self, buf=sys.stdout, offset=0, attrnames=False,
              showcoord=False ):
        lead = ' ' * offset
        buf.write( lead + 'filterblock: ' )
        if showcoord:
            buf.write( ' (at %s)' % self.coord )
        buf.write('\n')
        [x.show(buf, offset+2, attrnames, showcoord) for x in self.children()]


#---- Control Blocks

class IfelfiBlock( NonTerminal ):
    """class to handle `ifelfiblock` grammar."""

    def __init__( self, parser, ifelfiblock, ifblock, elifblock, elseblock ) :
        NonTerminal.__init__(self, parser, ifelfiblock, ifblock, elifblock, elseblock)
        self._nonterms = \
            self.ifelfiblock, self.ifblock, self.elifblock, self.elseblock = \
                ifelfiblock, ifblock, elifblock, elseblock
        self._nonterms = filter( None, self._nonterms )
        # Set parent attribute for children, should be last statement !!
        self.setparent( self, self.children() )

    def children( self ):
        return self._nonterms

    def show( self, buf=sys.stdout, offset=0, attrnames=False,
              showcoord=False ):
        lead = ' ' * offset
        buf.write( lead + 'ifelfiblock: ' )
        if showcoord:
            buf.write( ' (at %s)' % self.coord )
        buf.write('\n')
        [ x.show(buf, offset+2, attrnames, showcoord) for x in self.children() ]


class IfBlock( NonTerminal ):
    """class to handle `ifblock` grammar."""

    def __init__(self, parser, ifterm, dirtyblocks, indent, script, dedent):
        NonTerminal.__init__(
            self, parser, ifterm, dirtyblocks, indent, script, dedent )
        self._terms = self.IF, self.INDENT, self.DEDENT = ifterm, indent, dedent
        self._nonterms = self.dirtyblocks,self.script = dirtyblocks,script
        self._nonterms = filter( None, self._nonterms )
        # Set parent attribute for children, should be last statement !!
        self.setparent( self, self.children() )

    def children( self ):
        x = ( self.IF, self.dirtyblocks, self.INDENT, self.script,
              self.DEDENT )
        return filter(None, x)

    def generate( self, igen, *args, **kwargs ):
        line = self.IF.dump(None)
        line = ' '.join( line.replace( '@if', 'if' ).splitlines() )
        # if block
        self.gencontrolblock( igen, line, '', *args, **kwargs )
        return None

    def dump( self, context ) :
        text = self.IF.dump(context)
        context.htmlindent += self.INDENT.dump(context)
        text += self.dirtyblocks and self.dirtyblocks.dump(context) or ''
        text += self.script.dump(context)
        context.htmlindent = context.htmlindent[:-len(self.DEDENT.terminal)]
        return text

    def show( self, buf=sys.stdout, offset=0, attrnames=False,
              showcoord=False ):
        lead = ' ' * offset
        buf.write( lead + 'ifblock: ' )
        if showcoord:
            buf.write( ' (at %s)' % self.coord )
        buf.write('\n')
        [ x.show(buf, offset+2, attrnames, showcoord) for x in self.children() ]


class ElifBlock( NonTerminal ):
    """class to handle `elifblock` grammar."""

    def __init__( 
            self, parser, elifterm, dirtyblocks, indent, script, dedent ) :
        NonTerminal.__init__(
            self, parser, elifterm, dirtyblocks, indent, script, dedent )
        self._terms = self.ELIF, self.INDENT, self.DEDENT = \
                    elifterm, indent, dedent
        self._nonterms = self.dirtyblocks, self.script = dirtyblocks, script
        self._nonterms = filter( None, self._nonterms )
        # Set parent attribute for children, should be last statement !!
        self.setparent( self, self.children() )

    def children( self ):
        x = ( self.ELIF, self.dirtyblocks, self.INDENT, self.script,
              self.DEDENT )
        return filter(None, x)

    def generate( self, igen, *args, **kwargs ):
        line = self.ELIF.dump(None)
        line = ' '.join( line.replace( '@elif', 'elif' ).splitlines() )
        # elif block
        self.gencontrolblock( igen, line, '', *args, **kwargs )
        return None

    def dump( self, context ) :
        text = self.ELIF.dump(context)
        text += self.dirtyblocks and self.dirtyblocks.dump(context) or ''
        context.htmlindent += self.INDENT.dump(context)
        text += self.script.dump(context)
        context.htmlindent = context.htmlindent[:-len(self.DEDENT.terminal)]
        return text

    def show( self, buf=sys.stdout, offset=0, attrnames=False,
              showcoord=False ):
        lead = ' ' * offset
        buf.write( lead + 'elifblock: ' )
        if showcoord:
            buf.write( ' (at %s)' % self.coord )
        buf.write('\n')
        [ x.show(buf, offset+2, attrnames, showcoord) for x in self.children() ]


class ElseBlock( NonTerminal ):
    """class to handle `elseblock` grammar."""

    def __init__(self, parser, elseterm, dirtyblocks, indent, script, dedent):
        NonTerminal.__init__(
            self, parser, dirtyblocks, elseterm, indent, script, dedent )
        self._terms = self.ELSE, self.INDENT, self.DEDENT = \
                elseterm, indent, dedent
        self._nonterms = self.dirtyblocks,self.script = dirtyblocks,script
        self._nonterms = filter( None, self._nonterms )
        # Set parent attribute for children, should be last statement !!
        self.setparent( self, self.children() )

    def children( self ):
        x = ( self.ELSE, self.dirtyblocks, self.INDENT, self.script,
              self.DEDENT )
        return filter(None, x)

    def generate( self, igen, *args, **kwargs ):
        line = self.ELSE.dump(None)
        line = ' '.join( line.replace( '@else', 'else' ).splitlines() )
        # else block
        self.gencontrolblock( igen, line, '', *args, **kwargs )
        return None

    def dump( self, context ) :
        text = self.ELSE.dump(context)
        text += self.dirtyblocks and self.dirtyblocks.dump(context) or ''
        context.htmlindent += self.INDENT.dump(context)
        text += self.script.dump(context)
        context.htmlindent = context.htmlindent[:-len(self.DEDENT.terminal)]
        return text

    def show( self, buf=sys.stdout, offset=0, attrnames=False,
              showcoord=False ):
        lead = ' ' * offset
        buf.write( lead + 'elseblock: ' )
        if showcoord:
            buf.write( ' (at %s)' % self.coord )
        buf.write('\n')
        [ x.show(buf, offset+2, attrnames, showcoord) for x in self.children() ]


class ForBlock( NonTerminal ):
    """class to handle `elseblock` grammar."""

    def __init__(self, parser, forterm, dirtyblocks, indent, script, dedent):
        NonTerminal.__init__(
            self, parser, forterm, dirtyblocks, indent, script, dedent )
        self._terms = self.FOR, self.INDENT, self.DEDENT = \
                forterm, indent, dedent
        self._nonterms = self.dirtyblocks,self.script = dirtyblocks,script
        self._nonterms = filter( None, self._nonterms )
        # Set parent attribute for children, should be last statement !!
        self.setparent( self, self.children() )

    def children( self ):
        x = ( self.FOR, self.dirtyblocks, self.INDENT, self.script,
              self.DEDENT )
        return filter(None, x)

    def generate( self, igen, *args, **kwargs ):
        line = self.FOR.dump(None)
        line = ' '.join( line.replace( '@for', 'for' ).splitlines() )
        # for block
        self.gencontrolblock( igen, line, '', *args, **kwargs )
        return None

    def dump( self, context ) :
        text = self.FOR.dump(context)
        text += self.dirtyblocks and self.dirtyblocks.dump(context) or ''
        context.htmlindent += self.INDENT.dump(context)
        text += self.script.dump(context)
        context.htmlindent = context.htmlindent[:-len(self.DEDENT.terminal)]
        return text

    def show( self, buf=sys.stdout, offset=0, attrnames=False,
              showcoord=False ):
        lead = ' ' * offset
        buf.write( lead + 'forblock: ' )
        if showcoord:
            buf.write( ' (at %s)' % self.coord )
        buf.write('\n')
        [ x.show(buf, offset+2, attrnames, showcoord) for x in self.children() ]


class WhileBlock( NonTerminal ):
    """class to handle `whileblock` grammar."""

    def __init__( self, parser, whileterm, dirtyblocks, indent, script, dedent):
        NonTerminal.__init__(
            self, parser, whileterm, dirtyblocks, indent, script, dedent )
        self._terms = self.WHILE, self.INDENT, self.DEDENT = \
                whileterm, indent, dedent
        self._nonterms = self.dirtyblocks,self.script = dirtyblocks,script
        self._nonterms = filter( None, self._nonterms )
        # Set parent attribute for children, should be last statement !!
        self.setparent( self, self.children() )

    def children( self ):
        x = ( self.WHILE, self.dirtyblocks, self.INDENT, self.script,
              self.DEDENT )
        return filter(None, x)

    def generate( self, igen, *args, **kwargs ):
        line = self.WHILE.dump(None)
        line = ' '.join( line.replace( '@while', 'while' ).splitlines() )
        # while block
        self.gencontrolblock( igen, line, '', *args, **kwargs )
        return None

    def dump( self, context ) :
        text = self.WHILE.dump(context)
        text += self.dirtyblocks and self.dirtyblocks.dump(context) or ''
        context.htmlindent += self.INDENT.dump(context)
        text += self.script.dump(context)
        context.htmlindent = context.htmlindent[:-len(self.DEDENT.terminal)]
        return text

    def show( self, buf=sys.stdout, offset=0, attrnames=False,
              showcoord=False ):
        lead = ' ' * offset
        buf.write( lead + 'whileblock: ' )
        if showcoord:
            buf.write( ' (at %s)' % self.coord )
        buf.write('\n')
        [x.show(buf, offset+2, attrnames, showcoord) for x in self.children()]


#-------------------------- AST Terminals -------------------------

class NEWLINES( Terminal ) : pass

class INDENT( Terminal ):
    def generate( self, igen, *args, **kwargs ):
        pass
    def dump( self, context ) :
        return ''

class DEDENT( Terminal ):
    def generate( self, igen, *args, **kwargs ):
        pass
    def dump( self, context ) :
        return ''

class TEXT( Terminal ): pass

class DOCTYPE( Terminal ) : pass
class BODY( Terminal ) : pass
class IMPORTAS( Terminal ) : pass
class IMPLEMENT( Terminal ) : pass
class INHERIT( Terminal ) : pass
class USE( Terminal ) : pass

class COMMENTLINE( Terminal ) : pass
class STATEMENT( Terminal ) : pass
class TAGBEGIN( Terminal ) : pass

class COMMENTOPEN( Terminal ) : pass
class COMMENTTEXT( Terminal ) : pass
class COMMENTCLOSE( Terminal ) : pass
class FILTEROPEN( Terminal ) : pass
class FILTERTEXT( Terminal ) : pass
class FILTERCLOSE( Terminal ) : pass

class IF( Terminal ) : pass
class ELIF( Terminal ) : pass
class ELSE( Terminal ) : pass
class FOR( Terminal ) : pass
class WHILE( Terminal ) : pass

class FUNCTION( Terminal ) : pass
class INTERFACE( Terminal ) : pass

#---- XXXXXXXXX To be deleted XXXXXXXXXXXXX

class TAGOPEN( Terminal ):
    def checkprune( self ):
        from  tayra.lexer import TTLLexer
        tagopen = self.terminal
        self.pruneouter = tagopen[1] == TTLLexer.prunews
        if self.pruneouter :
            self.terminal = tagopen[0] + tagopen[2:]
        return self.pruneouter, None

    def _tagname( self ):
        from  tayra.lexer import TTLLexer
        return self.terminal.rstrip( TTLLexer.ws ).lstrip( '<!' )

    tagname = property( lambda self : self._tagname() )

class TAGCLOSE( Terminal ) :
    def checkprune( self ):
        from  tayra.lexer import TTLLexer
        tagclose = self.terminal
        self.pruneinner = TTLLexer.prunews in tagclose
        self.pruneindent = TTLLexer.pruneindent in tagclose
        if self.pruneinner or self.pruneindent :
            self.terminal = re.sub( r'[!%]', '', tagclose )
        return self.pruneinner, self.pruneindent
