# This file is subject to the terms and conditions defined in
# file 'LICENSE', which is part of this source code package.
#       Copyright (c) 2010 SKR Farms (P) LTD.

"""Module containing Node definition for all non-teminals nodes.

The AST tree is constructed according to the grammar. From the root
non-terminal use the children() method on every node to walk through the tree.

To walk throug the AST,
  * parse() the text, which returns the root non-terminal
  * Use children() method on every non-terminal node.
"""

# -*- coding: utf-8 -*-

# Gotcha : None
# Notes  : None
# Todo   : None
#   1. Add unicode support
#   2. Terminal, should be stored in UPPERCASE attributes.

import sys, re

class ASTError( Exception ):
    pass

# ------------------- AST Nodes (Terminal and Non-Terminal) -------------------

class Terminal( object ) :
    """Abstract base class for Tayra Style Sheet's AST terminal nodes."""

    def __init__( self, parser, terminal='', **kwargs ) :
        self.parser = parser
        self.terminal = terminal
        [ setattr( self, k, v ) for k,v in kwargs.items() ]

    def children( self ) :
        """Empty tuple of children"""
        return tuple()

    def tohtml( self ):
        """Translate the node and all the children nodes to html markup and
        return the content"""
        return self.terminal

    def ismatched( self ) :
        """This interface should return a boolean indicating whether the html
        generated by this node is matched. If a node expects that the html
        might be mismatched.
        After replacing etree with lxml mismatched elements are automatically
        taken care."""
        return True

    def dump( self ):
        """Simply dump the contents of this node and its children node and
        return the same."""
        return self.terminal

    def show( self, buf=sys.stdout, offset=0, attrnames=False,
              showcoord=False ):
        """ Pretty print the Node and all its attributes and children
        (recursively) to a buffer.
            
        buf:   
            Open IO buffer into which the Node is printed.
        
        offset: 
            Initial offset (amount of leading spaces) 
        
        attrnames:
            True if you want to see the attribute names in name=value pairs.
            False to only see the values.
        
        showcoord:
            Do you want the coordinates of each Node to be displayed.
        """
        lead = ' ' * offset
        buf.write(lead + '<%s>: %r' % (self.__class__.__name__, self.terminal))
        buf.write('\n')


class Node( object ):       # Non-terminal
    """Abstract base class for Tayra Style Sheet's AST non-terminalnodes."""

    def __init__( self, *args, **kwargs ) :
        self._terms, self._nonterms = tuple(), tuple()

    def children( self ):
        """List of all child nodes of type ``Nodes``"""
        pass

    def tohtml( self ):
        """Translate the node and all the children nodes to html markup and
        return the content"""

    def ismatched( self ) :
        """This interface should return a boolean indicating whether the html
        generated by this node is matched. If a node expects that the html
        might be mismatched.
        After replacing etree with lxml mismatched elements are automatically
        taken care."""
        return True

    def dump( self ):
        """Simply dump the contents of this node and its children node and
        return the same."""

    def show( self, buf=sys.stdout, offset=0, attrnames=False,
              showcoord=False ):
        """ Pretty print the Node and all its attributes and children
        (recursively) to a buffer.
            
        file:   
            Open IO buffer into which the Node is printed.
        
        offset: 
            Initial offset (amount of leading spaces) 
        
        attrnames:
            True if you want to see the attribute names in name=value pairs.
            False to only see the values.
        
        showcoord:
            Do you want the coordinates of each Node to be displayed."""
        pass

    def terminals( self ) :
        """Return a list of terminal nodes"""
        return getattr( self, '_terms', [] )

    def non_terminals( self ) :
        """Return a list of non-terminal nodes"""
        return getattr( self, '_nonterms', [] )


# ------------------- Non-terminal classes ------------------------

class Tss( Node ):
    """class to handle `tss` grammar."""

    def __init__( self, parser, stylesheets ) :
        Node.__init__( self, parser, stylesheets )
        self.parser = parser
        self.stylesheets = stylesheets
        self._nonterms = (self.stylesheets,)

    def children( self ):
        return self._nonterms

    def tohtml( self ):
        pass

    def dump( self ) :
        return ''.join([ c.dump() for c in self.children() ])

    def show( self, buf=sys.stdout, offset=0, attrnames=False,
              showcoord=False ):
        lead = ' ' * offset
        buf.write( lead + '-->tss: ' )
        if showcoord:
            buf.write( ' (at %s)' % self.coord )
        buf.write('\n')
        [ c.show(buf, offset+5, attrnames, showcoord) for c in self.children() ]


class StyleSheets( Node ):
    """class to handle `stylesheets` grammar."""

    def __init__( self, parser, stylesheets, stylesheet ) :
        Node.__init__( self, parser, stylesheets, stylesheet )
        self.parser = parser
        self._nonterms = self.stylesheets, self.stylesheet = \
                            stylesheets, stylesheet
        self._nonterms = filter( None, self._nonterms )

    def children( self ):
        return self._nonterms

    def tohtml( self ):
        pass

    def dump( self ) :
        # There is a potential danger is recursively calling dump() on the
        # children(). Instead collect the list of stylesheet nodes a list and
        # call dump() sequentially on them.
        return ''.join([ c.dump() for c in self.sslist() ])

    def show( self, buf=sys.stdout, offset=0, attrnames=False,
              showcoord=False ):
        if showcoord:
            buf.write( ' (at %s)' % self.coord )
        [ c.show(buf, offset, attrnames, showcoord) for c in self.sslist() ]

    def sslist( self ) :
        node, l = self, []
        while node :
            l.append( node.stylesheet )
            node = node.stylesheets
        l.reverse()
        return l



class StyleSheet( Node ):
    """class to handle `stylesheet` grammar."""

    def __init__( self, parser, rhs ) :
        Node.__init__( self, parser, rhs )
        self.parser = parser
        self.rhs = rhs
        self._nonterms = (self.rhs,)

    def children( self ):
        return self._nonterms

    def tohtml( self ):
        pass

    def dump( self ) :
        return ''.join([ c.dump() for c in self.children() ])

    def show( self, buf=sys.stdout, offset=0, attrnames=False,
              showcoord=False ):
        lead = ' ' * offset
        buf.write( lead + 'stylesheet: ' )
        if showcoord:
            buf.write( ' (at %s)' % self.coord )
        buf.write('\n')
        [ c.show(buf, offset+2, attrnames, showcoord) for c in self.children() ]


class Charset( Node ):
    """class to handle `charset` grammar."""

    def __init__( self, parser, charset_sym, string, semi ) :
        Node.__init__( self, parser, charset_sym, string, semi )
        self.parser = parser
        self.SEMICOLON = semi
        self._nonterms = self.charset_sym, self.string = charset_sym, string
        self._terms = (self.SEMICOLON,)

    def children( self ):
        return self._nonterms + self._terms

    def tohtml( self ):
        pass

    def dump( self ):
        return ''.join([ c.dump() for c in self.children() ])

    def show( self, buf=sys.stdout, offset=0, attrnames=False,
              showcoord=False ):
        lead = ' ' * offset
        buf.write( lead + 'charset: ' )
        if showcoord:
            buf.write( ' (at %s)' % self.coord )
        buf.write('\n')
        [ c.show(buf, offset+2, attrnames, showcoord) for c in self.children() ]


class Import( Node ) :
    """class to handle `import` grammar."""

    def __init__( self, parser, import_sym, str_uri, mediums, semi ) :
        Node.__init__( self, parser, import_sym, str_uri, mediums, semi )
        self.parser = parser
        self.SEMICOLON = semi
        self._nonterms = self.import_sym, self.str_uri, self.mediums = \
                import_sym, str_uri, mediums
        self._nonterms = filter( None, self._nonterms )
        self._terms = (self.SEMICOLON,)

    def children( self ) :
        return self._nonterms + self._terms

    def tohtml( self ):
        pass

    def dump( self ):
        return ''.join([ c.dump() for c in self.children() ])

    def show( self, buf=sys.stdout, offset=0, attrnames=False,
              showcoord=False ):
        lead = ' ' * offset
        buf.write( lead + 'import: ' )
        if showcoord:
            buf.write( ' (at %s)' % self.coord )
        buf.write('\n')
        [ c.show(buf, offset+2, attrnames, showcoord) for c in self.children() ]


class Namespace( Node ):
    """class to handle `namespace` grammar."""

    def __init__( self, parser, namespace_sym, prefix, str_uri, semi ) :
        Node.__init__( self, parser, namespace_sym, prefix, str_uri, semi )
        self.parser = parser
        self.SEMICOLON = semi
        self._nonterms = self.namespace_sym, self.prefix, self.str_uri = \
                namespace_sym, prefix, str_uri
        self._terms = (self.SEMICOLON,)

    def children( self ):
        return ( self.namespace_sym, self.prefix, self.str_uri, self.SEMICOLON )

    def tohtml( self ):
        pass

    def dump( self ):
        return ''.join([ c.dump() for c in self.children() ])

    def show( self, buf=sys.stdout, offset=0, attrnames=False,
              showcoord=False ):
        lead = ' ' * offset
        buf.write( lead + 'namespace: ' )
        if showcoord:
            buf.write( ' (at %s)' % self.coord )
        buf.write('\n')
        [ c.show(buf, offset+2, attrnames, showcoord) for c in self.children() ]


class Nameprefix( Node ) :
    """class to handle `nmprefix` grammar."""

    def __init__( self, parser, ident ) :
        Node.__init__( self, parser, ident )
        self.parser = parser
        self.ident = ident
        self._nonterms = (self.ident,)

    def children( self ):
        return self._nonterms

    def tohtml( self ):
        pass

    def dump( self ):
        return ''.join([ c.dump() for c in self.children() ])

    def show( self, buf=sys.stdout, offset=0, attrnames=False,
              showcoord=False ):
        lead = ' ' * offset
        txt = ''.join([ x.dump() for x in self.selectorlist() ])
        buf.write( lead + 'nmprefix: %r' % txt )
        if showcoord:
            buf.write( ' (at %s)' % self.coord )
        buf.write('\n')


class Statement( Node ):
    """class to handle `statement` grammar."""

    def __init__( self, parser, rhs ) :
        Node.__init__( self, parser, rhs )
        self.parser = parser
        self.rhs = rhs
        self._nonterms = ( self.rhs, )

    def children( self ):
        return self._nonterms

    def tohtml( self ):
        pass

    def dump( self ):
        return ''.join([ c.dump() for c in self.children() ])

    def show( self, buf=sys.stdout, offset=0, attrnames=False,
              showcoord=False ):
        lead = ' ' * offset
        buf.write( lead + 'statement: ' )
        if showcoord:
            buf.write( ' (at %s)' % self.coord )
        buf.write('\n')
        [ c.show(buf, offset+2, attrnames, showcoord) for c in self.children() ]


class Media( Node ):
    """class to handle `media` grammar."""

    def __init__( self, parser, media_sym, mediums, obrace, rulesets, cbrace ) :
        Node.__init__( self, parser, media_sym, mediums, obrace, rulesets, cbrace )
        self.parser = parser
        self.CLOSEBRACE = cbrace
        self._terms = ( self.CLOSEBRACE, )
        self._nonterms = \
            self.media_sym, self.mediums, self.openbrace, self.rulesets = \
                media_sym, mediums, obrace, rulesets
        self._nonterms = filter( None, self._nonterms )

    def children( self ) :
        x = [ self.media_sym, self.mediums, self.openbrace, self.rulesets,
              self.CLOSEBRACE ]
        return filter( None, x )

    def tohtml( self ) :
        pass

    def dump( self ):
        return ''.join([ c.dump() for c in self.children() ])

    def show( self, buf=sys.stdout, offset=0, attrnames=False,
              showcoord=False ):
        lead = ' ' * offset
        buf.write( lead + 'media: ' )
        if showcoord:
            buf.write( ' (at %s)' % self.coord )
        buf.write('\n')
        [ c.show(buf, offset+2, attrnames, showcoord) for c in self.children() ]


class Mediums( Node ):
    """class to handle `mediums` grammar."""

    def __init__( self, parser, mediums, comma, medium ) :
        Node.__init__( self, parser, mediums, comma, medium )
        self.parser = parser
        self._nonterms = self.mediums, self.comma, self.medium = \
                mediums, comma, medium
        self._nonterms = filter( None, self._nonterms )

    def children( self ):
        return self._nonterms

    def tohtml( self ):
        pass

    def dump( self ):
        return ''.join([ c.dump() for c in self.children() ])

    def show( self, buf=sys.stdout, offset=0, attrnames=False,
              showcoord=False ):
        lead = ' ' * offset
        buf.write( lead + 'mediums: ' )
        if showcoord:
            buf.write( ' (at %s)' % self.coord )
        buf.write('\n')
        [ c.show(buf, offset+2, attrnames, showcoord) for c in self.children() ]


class Medium( Node ) :
    """class to handle `medium` grammar."""

    def __init__( self, parser, nonterm ) :
        Node.__init__( self, parser, nonterm )
        self.parser = parser
        self.nonterm = nonterm
        self._nonterms = ( self.nonterm, )

    def children( self ) :
        return self._nonterms

    def tohtml( self ) :
        pass

    def dump( self ) :
        return ''.join([ c.dump() for c in self.children() ])

    def show( self, buf=sys.stdout, offset=0, attrnames=False,
              showcoord=False ) :
        lead = ' ' * offset
        buf.write( lead + 'medium: ' )
        if showcoord:
            buf.write( ' (at %s)' % self.coord )
        buf.write('\n')
        [ c.show(buf, offset+2, attrnames, showcoord) for c in self.children() ]


class Page( Node ) :
    """class to handle `page` grammar."""

    def __init__( self, parser, page_sym, ident, nonterm, block ) :
        Node.__init__( self, parser, page_sym, ident, nonterm, block )
        self.parser = parser
        self._nonterms = self.page_sym, self.nonterm, self.block = \
                page_sym, nonterm, block
        self.IDENT = ident
        if self.IDENt : self._terms = (self.IDENT,)

    def children( self ) :
        x = (self.page_sym, self.IDENT, self.nonterm, self.block)
        return filter(None, x)

    def tohtml( self ) :
        pass

    def dump( self ) :
        return ''.join([ c.dump() for c in self.children() ])

    def show( self, buf=sys.stdout, offset=0, attrnames=False,
              showcoord=False ) :
        lead = ' ' * offset
        buf.write( lead + 'page: ' )
        if showcoord:
            buf.write( ' (at %s)' % self.coord )
        buf.write('\n')
        [ c.show(buf, offset+2, attrnames, showcoord) for c in self.children() ]


class PseudoPage( Node ) :
    """class to handle `pseudo_page` grammar."""

    def __init__( self, parser, colon, ident ) :
        Node.__init__( self, parser, colon, ident )
        self.parser = parser
        self.COLON, self.ident = colon, ident
        self._terms = (self.COLON,)
        self._nonterms = (self.ident,)

    def children( self ) :
        return (self.COLON, self.ident)

    def tohtml( self ) :
        pass

    def dump( self ) :
        return ''.join([ c.dump() for c in self.children() ])

    def show( self, buf=sys.stdout, offset=0, attrnames=False,
              showcoord=False ) :
        lead = ' ' * offset
        buf.write( lead + 'pseudo_page: ' )
        if showcoord:
            buf.write( ' (at %s)' % self.coord )
        buf.write('\n')
        [ c.show(buf, offset+2, attrnames, showcoord) for c in self.children() ]


class FontFace( Node ) :
    """class to handle `font_face` grammar."""

    def __init__( self, parser, font_face_sym, block ) :
        Node.__init__( self, parser, font_face_sym, block )
        self.parser = parser
        self._nonterms = self.font_face_sym, self.block = font_face_sym, block

    def children( self ):
        return self._nonterms

    def tohtml( self ):
        pass

    def dump( self ):
        return ''.join([ c.dump() for c in self.children() ])

    def show( self, buf=sys.stdout, offset=0, attrnames=False,
              showcoord=False ):
        lead = ' ' * offset
        buf.write( lead + 'font_face: ' )
        if showcoord:
            buf.write( ' (at %s)' % self.coord )
        buf.write('\n')
        [ c.show(buf, offset+2, attrnames, showcoord) for c in self.children() ]


class AtRule( Node ) :
    """class to handle `atrule` grammar."""

    def __init__( self, parser, atkeyword, expr=None, block=None,
                  semicolon=None, obrace=None, rulesets=None, cbrace=None ) :
        Node.__init__( self, parser, atkeyword )
        self.parser = parser
        self._terms = self.SEMICOLON, self.CLOSEBRACE = semicolon, cbrace
        self._nonterms = \
            self.atkeyword, self.expr, self.block, self.obrace, self.rulesets =\
                atkeyword, expr, block, obrace, rulesets
        self._nonterms = filter( None, self._nonterms )
        self._terms = filter( None, self._terms )

    def children( self ):
        return self._nonterms + self._terms

    def tohtml( self ):
        pass

    def dump( self ):
        return ''.join([ c.dump() for c in self.children() ])

    def show( self, buf=sys.stdout, offset=0, attrnames=False,
              showcoord=False ):
        lead = ' ' * offset
        buf.write( lead + 'atrule: ' )
        if showcoord:
            buf.write( ' (at %s)' % self.coord )
        buf.write('\n')
        [ c.show(buf, offset+2, attrnames, showcoord) for c in self.children() ]


class RuleSets( Node ):
    """class to handle `rulesets` grammar."""

    def __init__( self, parser, rulesets, ruleset ) :
        Node.__init__( self, parser, rulesets, ruleset )
        self.parser = parser
        self._nonterms = self.rulesets, self.ruleset = rulesets, ruleset
        self._nonterms = filter( None, self._nonterms )

    def children( self ):
        return self._nonterms

    def tohtml( self ):
        pass

    def dump( self ):
        return ''.join([ c.dump() for c in self.children() ])

    def show( self, buf=sys.stdout, offset=0, attrnames=False,
              showcoord=False ):
        lead = ' ' * offset
        buf.write( lead + 'rulesets: ' )
        if showcoord:
            buf.write( ' (at %s)' % self.coord )
        buf.write('\n')
        [ c.show(buf, offset+2, attrnames, showcoord) for c in self.children() ]


class RuleSet( Node ):
    """class to handle `ruleset` grammar."""

    def __init__( self, parser, selectors, block ) :
        Node.__init__( self, parser, selectors, block )
        self.parser = parser
        self._nonterms = self.selectors, self.block = selectors, block
        self._nonterms = filter( None, self._nonterms )

    def children( self ):
        return self._nonterms

    def tohtml( self ):
        pass

    def dump( self ):
        return ''.join([ c.dump() for c in self.children() ])

    def show( self, buf=sys.stdout, offset=0, attrnames=False,
              showcoord=False ):
        lead = ' ' * offset
        buf.write( lead + 'ruleset: ' )
        if showcoord:
            buf.write( ' (at %s)' % self.coord )
        buf.write('\n')
        [ c.show(buf, offset+2, attrnames, showcoord) for c in self.children() ]


class Selectors( Node ):
    """class to handle `selectors` grammar."""

    def __init__( self, parser, selectors, comma, selector ) :
        Node.__init__( self, parser, selectors, comma, selector )
        self.parser = parser
        self._nonterms = self.selectors, self.comma, self.selector = \
                selectors, comma, selector
        self._nonterms = filter( None, self._nonterms )

    def children( self ):
        return self._nonterms

    def tohtml( self ):
        pass

    def dump( self ):
        return ''.join([ c.dump() for c in self.children() ])

    def show( self, buf=sys.stdout, offset=0, attrnames=False,
              showcoord=False ):
        lead = ' ' * offset
        buf.write( lead + 'selectors: ' )
        if showcoord:
            buf.write( ' (at %s)' % self.coord )
        buf.write('\n')
        [ c.show(buf, offset+2, attrnames, showcoord) for c in self.children() ]


class Selector( Node ):
    """class to handle `selector` grammar."""

    def __init__( self, parser, selector, combinator, simple_selector ) :
        Node.__init__( self, parser, selector, combinator, simple_selector )
        self.parser = parser
        self._nonterms = self.selector, self.combinator, self.simple_selector= \
                    selector, combinator, simple_selector
        self._nonterms = filter( None, self._nonterms )

    def children( self ):
        return self._nonterms

    def tohtml( self ):
        pass

    def dump( self ):
        return ''.join([ c.dump() for c in self.children() ])

    def show( self, buf=sys.stdout, offset=0, attrnames=False,
              showcoord=False ):
        lead = ' ' * offset
        buf.write( lead + 'selector: ' )
        if showcoord:
            buf.write( ' (at %s)' % self.coord )
        buf.write('\n')
        [ c.show(buf, offset+2, attrnames, showcoord) for c in self.children() ]


class SimpleSelector( Node ):
    """class to handle `simple_selector` grammar."""

    def __init__( self, parser, simple_selector, elemname, extender ) :
        Node.__init__( self, parser, simple_selector, elemname, extender )
        self.parser = parser
        self._nonterms = self.simple_selector, self.element_name, self.extender = \
                simple_selector, elemname, extender
        self._nonterms = filter( None, self._nonterms )

    def children( self ):
        return self._nonterms

    def tohtml( self ):
        pass

    def dump( self ):
        return ''.join([ c.dump() for c in self.children() ])

    def show( self, buf=sys.stdout, offset=0, attrnames=False,
              showcoord=False ):
        lead = ' ' * offset
        buf.write( lead + 'simple_selector: ' )
        if showcoord:
            buf.write( ' (at %s)' % self.coord )
        buf.write('\n')
        [ c.show(buf, offset+2, attrnames, showcoord) for c in self.children() ]


class ElementName( Node ):
    """class to handle `element_name` grammar."""

    def __init__( self, parser, nonterm ) :
        Node.__init__( self, parser, nonterm )
        self.parser = parser
        self.nonterm = nonterm
        self._nonterms = ( self.nonterm, )

    def children( self ):
        return self._nonterms

    def tohtml( self ):
        pass

    def dump( self ):
        return ''.join([ c.dump() for c in self.children() ])

    def show( self, buf=sys.stdout, offset=0, attrnames=False,
              showcoord=False ):
        lead = ' ' * offset
        buf.write( lead + 'element_name: ' )
        if showcoord:
            buf.write( ' (at %s)' % self.coord )
        buf.write('\n')
        [ c.show(buf, offset+2, attrnames, showcoord) for c in self.children() ]


class Extender( Node ):
    """class to handle `extender` grammar."""

    def __init__( self, parser, rhs ) :
        Node.__init__( self, parser, rhs )
        self.parser = parser
        self.rhs = rhs
        self._nonterms = ( self.rhs, )

    def children( self ):
        return self._nonterms

    def tohtml( self ):
        pass

    def dump( self ):
        return ''.join([ c.dump() for c in self.children() ])

    def show( self, buf=sys.stdout, offset=0, attrnames=False,
              showcoord=False ):
        lead = ' ' * offset
        buf.write( lead + 'extender: ' )
        if showcoord:
            buf.write( ' (at %s)' % self.coord )
        buf.write('\n')
        [ c.show(buf, offset+2, attrnames, showcoord) for c in self.children() ]


class Class( Node ):
    """class to handle `class` grammar."""

    def __init__( self, parser, dot, ident, wc ) :
        Node.__init__( self, parser, dot, ident, wc )
        self.parser = parser
        self.DOT, self.IDENT, self.wc = dot, ident, wc
        self._terms = (self.DOT, self.IDENT)
        if self.wc :
            self._nonterms = (self.wc,)

    def children( self ):
        return self._terms + self._nonterms

    def tohtml( self ):
        pass

    def dump( self ):
        return ''.join([ c.dump() for c in self.children() ])

    def show( self, buf=sys.stdout, offset=0, attrnames=False,
              showcoord=False ):
        lead = ' ' * offset
        buf.write( lead + 'class: ' )
        if showcoord:
            buf.write( ' (at %s)' % self.coord )
        buf.write('\n')
        [ c.show(buf, offset+2, attrnames, showcoord) for c in self.children() ]


class Attrib( Node ) :
    """class to handle `attrib` grammar."""

    def __init__( self, parser, osqr, ident, attroper, attrval, csqr ) :
        Node.__init__( self, parser, osqr, ident, attroper, attrval, csqr )
        self.parser = parser
        self._nonterms = \
            self.opensqr, self.ident, self.attroper, self.attrval, self.closesqr = \
                osqr, ident, attroper, attrval, csqr
        self._nonterms = filter( None, self._nonterms )

    def children( self ):
        return self._nonterms

    def tohtml( self ):
        pass

    def dump( self ):
        return ''.join([ c.dump() for c in self.children() ])

    def show( self, buf=sys.stdout, offset=0, attrnames=False,
              showcoord=False ):
        lead = ' ' * offset
        buf.write( lead + 'attrib: ' )
        if showcoord:
            buf.write( ' (at %s)' % self.coord )
        buf.write('\n')
        [ c.show(buf, offset+2, attrnames, showcoord) for c in self.children() ]


class AttrOper( Node ):
    """class to handle `attr_oper` grammar."""

    def __init__( self, parser, rhs ) :
        Node.__init__( self, parser, rhs )
        self.parser = parser
        self.rhs = rhs
        self._nonterms = ( self.rhs, )

    def children( self ):
        return self._nonterms

    def tohtml( self ):
        pass

    def dump( self ):
        return ''.join([ c.dump() for c in self.children() ])

    def show( self, buf=sys.stdout, offset=0, attrnames=False,
              showcoord=False ):
        lead = ' ' * offset
        buf.write( lead + 'attr_oper: ' )
        if showcoord:
            buf.write( ' (at %s)' % self.coord )
        buf.write('\n')
        [ c.show(buf, offset+2, attrnames, showcoord) for c in self.children() ]


class AttrVal( Node ):
    """class to handle `attr_val` grammar."""

    def __init__( self, parser, rhs ) :
        Node.__init__( self, parser, rhs )
        self.parser = parser
        self.rhs = rhs
        self._nonterms = ( self.rhs, )

    def children( self ):
        return self._nonterms

    def tohtml( self ):
        pass

    def dump( self ):
        return ''.join([ c.dump() for c in self.children() ])

    def show( self, buf=sys.stdout, offset=0, attrnames=False,
              showcoord=False ):
        lead = ' ' * offset
        buf.write( lead + 'attr_val: ' )
        if showcoord:
            buf.write( ' (at %s)' % self.coord )
        buf.write('\n')
        [ c.show(buf, offset+2, attrnames, showcoord) for c in self.children() ]


class Pseudo( Node ):
    """class to handle `pseudo` grammar."""

    def __init__( self, parser, colon1, colon2, pseudo_name ) :
        Node.__init__( self, parser, colon1, colon2, pseudo_name )
        self.parser = parser
        self._terms = self.COLON1, self.COLON2 = colon1, colon2
        self._terms = filter( None, self._terms )
        self.pseudo_name = pseudo_name
        self._nonterms = ( self.pseudo_name, )

    def children( self ):
        return self._terms + self._nonterms

    def tohtml( self ):
        pass

    def dump( self ):
        return ''.join([ c.dump() for c in self.children() ])

    def show( self, buf=sys.stdout, offset=0, attrnames=False,
              showcoord=False ):
        lead = ' ' * offset
        buf.write( lead + 'pseudo: ' )
        if showcoord:
            buf.write( ' (at %s)' % self.coord )
        buf.write('\n')
        [ c.show(buf, offset+2, attrnames, showcoord) for c in self.children() ]


class PseudoName( Node ):
    """class to handle `pseudo_name` grammar."""

    def __init__( self, parser, func, ident, cparan ) :
        Node.__init__( self, parser, func, ident, cparan )
        self.parser = parser
        self._nonterms = self.func, self.ident, self.closeparan = \
                func, ident, cparan
        self._nonterms = filter( None, self._nonterms )

    def children( self ):
        return self._nonterms

    def tohtml( self ):
        pass

    def dump( self ):
        return ''.join([ c.dump() for c in self.children() ])

    def show( self, buf=sys.stdout, offset=0, attrnames=False,
              showcoord=False ):
        lead = ' ' * offset
        buf.write( lead + 'pseudo_name: ' )
        if showcoord:
            buf.write( ' (at %s)' % self.coord )
        buf.write('\n')
        [ c.show(buf, offset+2, attrnames, showcoord) for c in self.children() ]


#class Blocks( Node ):
#    """class to handle `blocks` grammar."""
#
#    def __init__( self, parser, blocks, block ) :
#        Node.__init__( self, parser, blocks, block )
#        self.parser = parser
#        self._nonterms = self.blocks, self.block = blocks, block
#        self._nonterms = filter( None, self._nonterms )
#
#    def children( self ):
#        return self._nonterms
#
#    def tohtml( self ):
#        pass
#
#    def dump( self ):
#        return ''.join([ c.dump() for c in self.children() ])
#
#    def show( self, buf=sys.stdout, offset=0, attrnames=False,
#              showcoord=False ):
#        lead = ' ' * offset
#        buf.write( lead + 'blocks: ' )
#        if showcoord:
#            buf.write( ' (at %s)' % self.coord )
#        buf.write('\n')
#        [ c.show(buf, offset+2, attrnames, showcoord) for c in self.children() ]


class Block( Node ):
    """class to handle `block` grammar."""

    def __init__( self, parser, obrace, declarations, cbrace ) :
        Node.__init__( self, parser, obrace, declarations, cbrace )
        self.parser = parser
        self._nonterms = self.openbrace, self.declarations, self.closebrace = \
                obrace, declarations, cbrace
        self._nonterms = filter( None, self._nonterms )

    def children( self ):
        return self._nonterms

    def tohtml( self ):
        pass

    def dump( self ):
        return ''.join([ c.dump() for c in self.children() ])

    def show( self, buf=sys.stdout, offset=0, attrnames=False,
              showcoord=False ):
        lead = ' ' * offset
        buf.write( lead + 'block: ' )
        if showcoord:
            buf.write( ' (at %s)' % self.coord )
        buf.write('\n')
        [ c.show(buf, offset+2, attrnames, showcoord) for c in self.children() ]


class Declarations( Node ):
    """class to handle `declarations` grammar."""

    def __init__( self, parser, declarations, semi, declaration ) :
        Node.__init__( self, parser, declarations, semi, declaration )
        self.parser = parser
        self._nonterms = self.declarations, self.semicolon, self.declaration = \
                declarations, semi, declaration
        self._nonterms = filter( None, self._nonterms )

    def children( self ):
        return self._nonterms

    def tohtml( self ):
        pass

    def dump( self ):
        return ''.join([ c.dump() for c in self.children() ])

    def show( self, buf=sys.stdout, offset=0, attrnames=False,
              showcoord=False ):
        lead = ' ' * offset
        buf.write( lead + 'declarations: ' )
        if showcoord:
            buf.write( ' (at %s)' % self.coord )
        buf.write('\n')
        [ c.show(buf, offset+2, attrnames, showcoord) for c in self.children() ]


class Declaration( Node ):
    """class to handle `declaration` grammar."""

    def __init__( self, parser, prefix, ident, colon, expr, prio ) :
        Node.__init__( self, parser, prefix, ident, colon, expr, prio )
        self.parser = parser
        self._nonterms = \
            self.prefix, self.ident, self.colon, self.expr, self.prio = \
                prefix, ident, colon, expr, prio
        self._nonterms = filter( None, self._nonterms )

    def children( self ):
        return self._nonterms

    def tohtml( self ):
        pass

    def dump( self ):
        return ''.join([ c.dump() for c in self.children() ])

    def show( self, buf=sys.stdout, offset=0, attrnames=False,
              showcoord=False ):
        lead = ' ' * offset
        buf.write( lead + 'declaration: ' )
        if showcoord:
            buf.write( ' (at %s)' % self.coord )
        buf.write('\n')
        [ c.show(buf, offset+2, attrnames, showcoord) for c in self.children() ]


class Property( Node ):
    """class to handle `property` grammar."""

    def __init__( self, parser, prefix, ident ) :
        Node.__init__( self, parser, prefix, ident )
        self.parser = parser
        self._nonterms = self.prefix, self.ident = prefix, ident
        self._nonterms = filter( None, self._nonterms )

    def children( self ):
        return self._nonterms

    def tohtml( self ):
        pass

    def dump( self ):
        return ''.join([ c.dump() for c in self.children() ])

    def show( self, buf=sys.stdout, offset=0, attrnames=False,
              showcoord=False ):
        lead = ' ' * offset
        buf.write( lead + 'property: ' )
        if showcoord:
            buf.write( ' (at %s)' % self.coord )
        buf.write('\n')
        [ c.show(buf, offset+2, attrnames, showcoord) for c in self.children() ]


class Priority( Node ):
    """class to handle `prio` grammar."""

    def __init__( self, parser, important_sym ) :
        Node.__init__( self, parser, important_sym )
        self.parser = parser
        self.important_sym = important_sym
        self._nonterms = ( self.important_sym, )

    def children( self ):
        return self._nonterms

    def tohtml( self ):
        pass

    def dump( self ):
        return ''.join([ c.dump() for c in self.children() ])

    def show( self, buf=sys.stdout, offset=0, attrnames=False,
              showcoord=False ):
        lead = ' ' * offset
        buf.write( lead + 'prio: ' )
        if showcoord:
            buf.write( ' (at %s)' % self.coord )
        buf.write('\n')
        [ c.show(buf, offset+2, attrnames, showcoord) for c in self.children() ]


class Expr( Node ):
    """class to handle `expr` grammar."""

    def __init__( self, parser, expr, binaryexpr ) :
        Node.__init__( self, parser, expr, binaryexpr )
        self.parser = parser
        self._nonterms = self.expr, self.binaryexpr = expr, binaryexpr
        self._nonterms = filter( None, self._nonterms )

    def children( self ):
        return self._nonterms

    def tohtml( self ):
        pass

    def dump( self ):
        return ''.join([ c.dump() for c in self.children() ])

    def show( self, buf=sys.stdout, offset=0, attrnames=False,
              showcoord=False ):
        lead = ' ' * offset
        buf.write( lead + 'expr: ' )
        if showcoord:
            buf.write( ' (at %s)' % self.coord )
        buf.write('\n')
        [ c.show(buf, offset+2, attrnames, showcoord) for c in self.children() ]


class BinaryExpr( Node ):
    """class to handle `binaryexpr` grammar."""

    def __init__( self, parser, binaryexpr1, op, binaryexpr2, item ) :
        Node.__init__( self, parser )
        self.parser = parser
        self._nonterms = \
            self.binaryexpr1, self.operator, self.binaryexpr2, self.item = \
                binaryexpr1, op, binaryexpr2, item
        self._nonterms = filter( None, self._nonterms )

    def children( self ):
        return self._nonterms

    def tohtml( self ):
        pass

    def dump( self ):
        return ''.join([ c.dump() for c in self.children() ])

    def show( self, buf=sys.stdout, offset=0, attrnames=False,
              showcoord=False ):
        lead = ' ' * offset
        buf.write( lead + 'binaryexpr: ' )
        if showcoord:
            buf.write( ' (at %s)' % self.coord )
        buf.write('\n')
        [ c.show(buf, offset+2, attrnames, showcoord) for c in self.children() ]


class UnaryExpr( Node ):
    """class to handle `unaryexpr` grammar."""

    def __init__( self, parser, unaryop, term_val, paran_expr ) :
        Node.__init__( self, parser, unaryop, term_val )
        self.parser = parser
        if paran_expr :
            self.openparan, self.expr, self.closeparan = paran_expr
            self._nonterms = paran_expr
        else :
            self._nonterms = self.unaryop, self.term_val = unaryop, term_val
        self._nonterms = filter( None, self._nonterms )

    def children( self ):
        return self._nonterms

    def tohtml( self ):
        pass

    def dump( self ):
        return ''.join([ c.dump() for c in self.children() ])

    def show( self, buf=sys.stdout, offset=0, attrnames=False,
              showcoord=False ):
        lead = ' ' * offset
        buf.write( lead + 'unaryexpr: ' )
        if showcoord:
            buf.write( ' (at %s)' % self.coord )
        buf.write('\n')
        [ c.show(buf, offset+2, attrnames, showcoord) for c in self.children() ]


class Term( Node ):
    """class to handle `term` grammar."""

    def __init__( self, parser, rhs ) :
        Node.__init__( self, parser, rhs )
        self.parser = parser
        self.rhs = rhs
        self._nonterms = (self.rhs,)

    def children( self ):
        return self._nonterms

    def tohtml( self ):
        pass

    def dump( self ):
        return ''.join([ c.dump() for c in self.children() ])

    def show( self, buf=sys.stdout, offset=0, attrnames=False,
              showcoord=False ):
        lead = ' ' * offset
        buf.write( lead + 'term: ' )
        if showcoord:
            buf.write( ' (at %s)' % self.coord )
        buf.write('\n')
        [ c.show(buf, offset+2, attrnames, showcoord) for c in self.children() ]


class TermVal( Node ):
    """class to handle `term_val` grammar."""

    def __init__( self, parser, rhs ) :
        Node.__init__( self, parser, rhs )
        self.parser = parser
        self.rhs = rhs
        self._nonterms = (self.rhs,)

    def children( self ):
        return self._nonterms

    def tohtml( self ):
        pass

    def dump( self ):
        return ''.join([ c.dump() for c in self.children() ])

    def show( self, buf=sys.stdout, offset=0, attrnames=False,
              showcoord=False ):
        lead = ' ' * offset
        buf.write( lead + 'term_val: ' )
        if showcoord:
            buf.write( ' (at %s)' % self.coord )
        buf.write('\n')
        [ c.show(buf, offset+2, attrnames, showcoord) for c in self.children() ]


class Func( Node ):
    """class to handle `func` grammar."""

    def __init__( self, parser, function, expr, closeparan ) :
        Node.__init__( self, parser, function, expr, closeparan )
        self.parser = parser
        self._nonterms = self.function, self.expr, self.closeparan = \
                function, expr, closeparan
        self._nonterms = filter( None, self._nonterms )

    def children( self ):
        return self._nonterms

    def tohtml( self ):
        pass

    def dump( self ):
        return ''.join([ c.dump() for c in self.children() ])

    def show( self, buf=sys.stdout, offset=0, attrnames=False,
              showcoord=False ):
        lead = ' ' * offset
        buf.write( lead + 'func: ' )
        if showcoord:
            buf.write( ' (at %s)' % self.coord )
        buf.write('\n')
        [ c.show(buf, offset+2, attrnames, showcoord) for c in self.children() ]


class Operator( Node ):
    """class to handle `operator` grammar."""

    def __init__( self, parser, nonterm ) :
        Node.__init__( self, parser, nonterm )
        self.parser = parser
        self.nonterm = nonterm
        self._nonterms = ( self.nonterm, )

    def children( self ):
        return self._nonterms

    def tohtml( self ):
        pass

    def dump( self ):
        return ''.join([ c.dump() for c in self.children() ])

    def show( self, buf=sys.stdout, offset=0, attrnames=False,
              showcoord=False ):
        lead = ' ' * offset
        buf.write( lead + 'operator: ' )
        if showcoord:
            buf.write( ' (at %s)' % self.coord )
        buf.write('\n')
        [ c.show(buf, offset+2, attrnames, showcoord) for c in self.children() ]


class Unary( Node ):
    """class to handle `unary_oper` grammar."""

    def __init__( self, parser, terminal ) :
        Node.__init__( self, parser, terminal )
        self.parser = parser
        self.TERMINAL = terminal
        self._terms = ( self.TERMINAL, )

    def children( self ):
        return self._terms

    def tohtml( self ):
        pass

    def dump( self ):
        return ''.join([ c.dump() for c in self.children() ])

    def show( self, buf=sys.stdout, offset=0, attrnames=False,
              showcoord=False ):
        lead = ' ' * offset
        buf.write( lead + 'unary_oper: ' )
        if showcoord:
            buf.write( ' (at %s)' % self.coord )
        buf.write('\n')
        [ c.show(buf, offset+2, attrnames, showcoord) for c in self.children() ]


class Combinator( Node ):
    """class to handle `combinator` grammar."""

    def __init__( self, parser, nonterm ) :
        Node.__init__( self, parser, nonterm )
        self.parser = parser
        self.nonterm = nonterm
        self._nonterms = ( self.nonterm, )

    def children( self ):
        return self._nonterms

    def tohtml( self ):
        pass

    def dump( self ):
        return ''.join([ c.dump() for c in self.children() ])

    def show( self, buf=sys.stdout, offset=0, attrnames=False,
              showcoord=False ):
        lead = ' ' * offset
        buf.write( lead + 'combinator: ' )
        if showcoord:
            buf.write( ' (at %s)' % self.coord )
        buf.write('\n')
        [ c.show(buf, offset+2, attrnames, showcoord) for c in self.children() ]


class Cdatas( Node ):
    """class to handle `cdatas` grammar."""

    def __init__( self, parser, cdatas, cdata ) :
        Node.__init__( self, parser, cdata, cdata )
        self.parser = parser
        self._nonterms = self.cdatas, self.cdata = cdatas, cdata
        self._nonterms = filter( None, self._nonterms )

    def children( self ):
        return self._nonterms

    def tohtml( self ):
        pass

    def dump( self ):
        return ''.join([ c.dump() for c in self.children() ])

    def show( self, buf=sys.stdout, offset=0, attrnames=False,
              showcoord=False ):
        lead = ' ' * offset
        buf.write( lead + 'cdatas: ' )
        if showcoord:
            buf.write( ' (at %s)' % self.coord )
        buf.write('\n')
        [ c.show(buf, offset+2, attrnames, showcoord) for c in self.children() ]


class Cdata( Node ):
    """class to handle `cdata` grammar."""

    def __init__( self, parser, cdo, cdata_conts, cdc ) :
        Node.__init__( self, parser, cdo, cdata_conts, cdc )
        self.parser = parser
        self._nonterms = self.cdo, self.cdata_conts, self.cdc = \
                cdo, cdata_conts, cdc
        self._nonterms = filter( None, self._nonterms )

    def children( self ):
        return self._nonterms

    def tohtml( self ):
        pass

    def dump( self ):
        return ''.join([ c.dump() for c in self.children() ])

    def show( self, buf=sys.stdout, offset=0, attrnames=False,
              showcoord=False ):
        lead = ' ' * offset
        buf.write( lead + 'cdata: ' )
        if showcoord:
            buf.write( ' (at %s)' % self.coord )
        buf.write('\n')
        [ c.show(buf, offset+2, attrnames, showcoord) for c in self.children() ]


class CdataConts( Node ):
    """class to handle `cdata_conts` grammar."""

    def __init__( self, parser, cdata_conts, cdata_cont ) :
        Node.__init__( self, parser, cdata_conts, cdata_cont )
        self.parser = parser
        self._nonterms = self.cdata_conts, self.cdata_cont = \
                cdata_conts, cdata_cont
        self._nonterms = filter( None, self._nonterms )

    def children( self ):
        return self._nonterms

    def tohtml( self ):
        pass

    def dump( self ):
        return ''.join([ c.dump() for c in self.children() ])

    def show( self, buf=sys.stdout, offset=0, attrnames=False,
              showcoord=False ):
        lead = ' ' * offset
        buf.write( lead + 'cdata_conts: ' )
        if showcoord:
            buf.write( ' (at %s)' % self.coord )
        buf.write('\n')
        [ c.show(buf, offset+2, attrnames, showcoord) for c in self.children() ]


class CdataCont( Node ):
    """class to handle `cdata_cont` grammar."""

    def __init__( self, parser, item ) :
        Node.__init__( self, parser, item )
        self.parser = parser
        self.item = item
        self._nonterms = (self.item,)

    def children( self ):
        return self._nonterms

    def tohtml( self ):
        pass

    def dump( self ):
        return ''.join([ c.dump() for c in self.children() ])

    def show( self, buf=sys.stdout, offset=0, attrnames=False,
              showcoord=False ):
        lead = ' ' * offset
        buf.write( lead + 'cdata_cont: ' )
        if showcoord:
            buf.write( ' (at %s)' % self.coord )
        buf.write('\n')
        [ c.show(buf, offset+2, attrnames, showcoord) for c in self.children() ]


class TerminalS( Node ):
    """class to handle terminal tokens is optionally succeeded by whitespace
    grammar."""

    def __init__( self, parser, terminal, ws ) :
        Node.__init__( self, parser, terminal, ws )
        self.parser = parser
        self._terms = self.TERMINAL, self.S = terminal, ws
        self._terms = filter( None, self._terms )

    def children( self ):
        return self._terms

    def tohtml( self ):
        pass

    def dump( self ):
        return ''.join([ c.dump() for c in self.children() ])

    def show( self, buf=sys.stdout, offset=0, attrnames=False,
              showcoord=False ):
        if showcoord:
            buf.write( ' (at %s)' % self.coord )
        [ c.show(buf, offset, attrnames, showcoord) for c in self.children() ]


class WC( Node ):
    """class to handle `wc` grammar."""

    def __init__( self, parser, wc, s, comment ) :
        Node.__init__( self, parser, s, comment )
        self.parser = parser
        self.wc, self.S, self.COMMENT = wc, s, comment
        self._terms = filter( None, (self.S, self.COMMENT) )
        if self.wc :
            self._nonterms = (self.wc,)

    def children( self ):
        return self._nonterms + self._terms

    def tohtml( self ):
        pass

    def dump( self ):
        return ''.join([ c.dump() for c in self.children() ])

    def show( self, buf=sys.stdout, offset=0, attrnames=False,
              showcoord=False ):
        if showcoord:
            buf.write( ' (at %s)' % self.coord )
        [ c.show(buf, offset, attrnames, showcoord) for c in self.children() ]


class Any( Node ):
    """class to handle `any` grammar."""

    def __init__( self, parser, open_, expr, close_ ) :
        Node.__init__( self, parser, open_, expr, close_ )
        self.parser = parser
        self._nonterms = self.open_, self.expr, self.close_ = open_, expr, close_

    def children( self ):
        return self._nonterms + self._terms

    def tohtml( self ):
        pass

    def dump( self ):
        return ''.join([ c.dump() for c in self.children() ])

    def show( self, buf=sys.stdout, offset=0, attrnames=False,
              showcoord=False ):
        if showcoord:
            buf.write( ' (at %s)' % self.coord )
        [ c.show(buf, offset, attrnames, showcoord) for c in self.children() ]


#-------------------------- AST Terminals -------------------------

class CHARSET_SYM( Terminal ) : pass
class IMPORT_SYM( Terminal ) : pass
class NAMESPACE_SYM( Terminal ) : pass
class MEDIA_SYM( Terminal ) : pass
class PAGE_SYM( Terminal ) : pass
class FONT_FACE_SYM( Terminal ) : pass
class IMPORTANT_SYM( Terminal ) : pass
class ATKEYWORD( Terminal ) : pass
class URI( Terminal ) : pass
class CDO( Terminal ) : pass
class CDC( Terminal ) : pass
class INCLUDES( Terminal ) : pass
class DASHMATCH( Terminal ) : pass
class BEGINMATCH( Terminal ) : pass
class ENDMATCH( Terminal ) : pass
class CONTAIN( Terminal ) : pass
class HEXCOLOR( Terminal ) : pass
class PERCENTAGE( Terminal ) : pass
class NUMBER( Terminal ) : pass
class EMS( Terminal ) : pass
class EXS( Terminal ) : pass
class LENGTH_PX( Terminal ) : pass
class LENGTH_MM( Terminal ) : pass
class LENGTH_CM( Terminal ) : pass
class LENGTH_IN( Terminal ) : pass
class LENGTH_PT( Terminal ) : pass
class LENGTH_PC( Terminal ) : pass
class ANGLE_DEG( Terminal ) : pass
class ANGLE_RAD( Terminal ) : pass
class ANGLE_GRAD( Terminal ) : pass
class TIME_MS( Terminal ) : pass
class TIME_S( Terminal ) : pass
class FREQ_HZ( Terminal ) : pass
class FREQ_KHZ( Terminal ) : pass
class STRING( Terminal ) : pass
class FUNCTION( Terminal ) : pass
class IDENT( Terminal ) : pass
class NAME( Terminal ) : pass
class UNICODERANGE( Terminal ) : pass

class PLUS( Terminal ) : pass
class GT( Terminal ) : pass
class LT( Terminal ) : pass
class COMMA( Terminal ) : pass
class COLON( Terminal ) : pass
class MINUS( Terminal ) : pass
class EQUAL( Terminal ) : pass
class DOT( Terminal ) : pass
class STAR( Terminal ) : pass
class HASH( Terminal ) : pass
class SEMICOLON( Terminal ) : pass
class FWDSLASH( Terminal ) : pass
class TILDA( Terminal ) : pass
class DLIMIT( Terminal ) : pass

class OPENBRACE( Terminal ) : pass
class CLOSEBRACE( Terminal ) : pass
class OPENSQR( Terminal ) : pass
class CLOSESQR( Terminal ) : pass
class OPENPARAN( Terminal ) : pass
class CLOSEPARAN( Terminal ) : pass

class S( Terminal ) : pass
class COMMENT( Terminal ) : pass
