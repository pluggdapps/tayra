# This file is subject to the terms and conditions defined in
# file 'LICENSE', which is part of this source code package.
#       Copyright (c) 2010 SKR Farms (P) LTD.

"""Module containing Node definition for all non-teminals nodes.

The AST tree is constructed according to the grammar. From the root
non-terminal use the children() method on every node to walk through the tree.

To walk throug the AST,
  * parse() the text, which returns the root non-terminal
  * Use children() method on every non-terminal node.
"""

# -*- coding: utf-8 -*-

# Gotcha : None
# Notes  : None
# Todo   : None

import sys, re, types
from   hashlib          import sha1

class ASTError( Exception ):
    pass

class Context( object ):
    def __init__( self, htmlindent='' ):
        self.htmlindent = htmlindent

# ------------------- AST Nodes (Terminal and Non-Terminal) -------------------

class Node( object ):

    def __init__( self, parser ):
        self.parser = parser
        self.parent = None

    def children( self ):
        """Empty tuple of children"""
        return tuple()

    def validate( self, context ):
        """Validate AST"""
        pass

    def preprocess( self, igen ):
        """Pre-processing phase."""
        [ x.preprocess( igen ) for x in self.children() ]

    def generate( self, igen, *args, **kwargs ):
        """Code generation phase. The result must be an executable python
        script"""
        [ x.generate( igen, *args, **kwargs ) for x in self.children() ]

    def execute( self, context ):
        """Execute the generated code for HTML output"""
        pass

    def dump( self, context ):
        """Simply dump the contents of this node and its children node and
        return the same."""
        return ''.join([ x.dump(context) for x in self.children() ])

    def ismatched( self, context ):
        """This interface should return a boolean indicating whether the html
        generated by this node is matched. If a node expects that the html
        might be mismatched.
        After replacing etree with lxml mismatched elements are automatically
        taken care."""
        return True

    def show( self, buf=sys.stdout, offset=0, attrnames=False,
              showcoord=False ):
        """ Pretty print the Node and all its attributes and children
        (recursively) to a buffer.
            
        buf:   
            Open IO buffer into which the Node is printed.
        
        offset: 
            Initial offset (amount of leading spaces) 
        
        attrnames:
            True if you want to see the attribute names in name=value pairs.
            False to only see the values.
        
        showcoord:
            Do you want the coordinates of each Node to be displayed.
        """

    def stackcompute( self, igen, compute, astext=True ):
        igen.pushbuf()
        compute()
        igen.popcompute( astext=astext )
        return None

    def getroot( self ):
        node = self
        parent = node.parent
        while parent : node, parent = parent, parent.parent
        return node

    def bubbleup( self, attrname, value ):
        rootnode = self.getroot()
        setattr( rootnode, attrname, value )

    def bubbleupaccum( self, attrname, value, to=None ):
        rootnode = self.getroot()
        l = getattr( rootnode, attrname, [] )
        l.append( value )
        setattr( rootnode, attrname, l )

    @classmethod
    def setparent( cls, parnode, childnodes ):
        [ setattr( n, 'parent', parnode ) for n in childnodes ]


class Terminal( Node ) :
    """Abstract base class for Tayra Template's AST terminal nodes."""

    def __init__( self, parser, terminal=u'', **kwargs ):
        Node.__init__( self, parser )
        self.terminal = terminal
        [ setattr( self, k, v ) for k,v in kwargs.items() ]

    def __repr__( self ):
        return unicode( self.terminal )

    def __str__( self ):
        return unicode( self.terminal )

    def generate( self, igen, *args, **kwargs ):
        igen.puttext( self.dump(None) )

    def dump( self, context ):
        """Simply dump the contents of this node and its children node and
        return the same."""
        return self.terminal

    def show( self, buf=sys.stdout, offset=0, attrnames=False,
              showcoord=False ):
        """ Pretty print the Node and all its attributes and children
        (recursively) to a buffer.
            
        buf:   
            Open IO buffer into which the Node is printed.
        
        offset: 
            Initial offset (amount of leading spaces) 
        
        attrnames:
            True if you want to see the attribute names in name=value pairs.
            False to only see the values.
        
        showcoord:
            Do you want the coordinates of each Node to be displayed.
        """
        lead = ' ' * offset
        buf.write(lead + '<%s>: %r' % (self.__class__.__name__, self.terminal))
        buf.write('\n')



class NonTerminal( Node ):      # Non-terminal
    """Abstract base class for Tayra Template's AST non-terminalnodes."""

    def __init__( self, *args, **kwargs ) :
        parser = args[0]
        Node.__init__( self, parser )
        self._terms, self._nonterms = tuple(), tuple()

    def terminals( self ):
        """Return a list of terminal nodes"""
        return getattr( self, '_terms', [] )

    def non_terminals( self ):
        """Return a list of non-terminal nodes"""
        return getattr( self, '_nonterms', [] )

    def gencontrolblock( self, igen, line, *args, **kwargs ):
        igen.indent()
        igen.comment( line )
        igen.blockbegin( line )
        if self.siblings :
            igen.upindent( self.INDENT )
            self.siblings.generate( igen, *args, **kwargs )
            igen.downindent( self.DEDENT )
        else :
            self.putstatement('pass')
        return None

    def flatten( self, attrnode, attrs ):
        node, rclist = self, []

        if isinstance(attrs, basestring) :
            fn = lambda n : [ getattr(n, attrs) ]
        elif isinstance(attrs, (list,tuple)) :
            fn = lambda n : [ getattr(n, attr) for attr in attrs ]
        else :
            fn = attrs

        while node :
            rclist.extend( filter( None, list(fn(node))) )
            node = getattr(node, attrnode)
        rclist.reverse()
        return rclist


# ------------------- Non-terminal classes ------------------------

class Template( NonTerminal ):
    """class to handle `template` grammar."""

    def __init__( self, parser, commentline, prologs, siblings ):
        NonTerminal.__init__( self, parser, commentline, prologs, siblings )
        self._nonterms = self.commentline, self.prologs, self.siblings = \
                commentline, prologs, siblings
        self._nonterms = filter( None, self._nonterms )
        # Set parent attribute for children, should be last statement !!
        self.setparent( self, self.children() )
        self.bodysignature = None   # Will be bubbleup during `preprocess`
        self.implements = []        # [ (interface, pluginname), ...]
        self.interfaces = []        # [ (interface, method), ... ]
        self.doctypes = []          # [ html, html, ... ]

    def _genbodyfun( self, igen, signature='' ):
        signature = signature and signature.strip(', \t') or ''
        ', '.join([ signature, '*args', '**kwargs' ])
        line = "def body( %s ) :" % signature
        igen.blockbegin( line, pyindent=bool(self.children()) )

    def children( self ):
        return self._nonterms

    def generate( self, igen, *args, **kwargs ):
        self._genbodyfun( igen, self.bodysignature )
        self.prologs and self.prologs.generate( igen, *args, **kwargs )
        for html in self.doctypes :
            igen.puttext( html+'\n', force=True )
        igen.puttext('\n')
        self.siblings and self.siblings.generate( igen, *args, **kwargs )
        # finish body function
        igen.flushtext()
        igen.popreturn( astext=True )
        # Handle interface implementations
        if self.implements and self.interfaces :
            igen.implement_interface( self.implements, self.interfaces )
        # Footer
        ttlfile = self.parser.ttlparser.ttlfile
        ttlhash = sha1( self.dump( Context() )).hexdigest()
        igen.footer( ttlhash, ttlfile )

    def dump( self, context=None ):
        c = context or Context()
        return ''.join([ x.dump(c) for x in self.children() ])

    def show( self, buf=sys.stdout, offset=0, attrnames=False,
              showcoord=False ):
        lead = ' ' * offset
        buf.write( lead + '-->template: ' )
        if showcoord:
            buf.write( ' (at %s)' % self.coord )
        buf.write('\n')
        [ x.show(buf, offset+5, attrnames, showcoord) for x in self.children() ]


class Prologs( NonTerminal ):
    """class to handle `prologs` grammar."""

    def __init__( self, parser, prologs, prolog ) :
        NonTerminal.__init__( self, parser, prologs, prolog )
        self._nonterms = self.prologs, self.prolog = prologs, prolog
        self._nonterms = filter( None, self._nonterms )
        # Set parent attribute for children, should be last statement !!
        self.setparent( self, self.children() )

    def children( self ):
        return self._nonterms

    def show( self, buf=sys.stdout, offset=0, attrnames=False,
              showcoord=False ):
        if showcoord:
            buf.write( ' (at %s)' % self.coord )
        prologlist = self.flatten()
        [ x.show(buf, offset, attrnames, showcoord) for x in prologlist ]

    def flatten( self ) :
        return NonTerminal.flatten( self, 'prologs', 'prolog' )


class Prolog( NonTerminal ):
    """class to handle `prolog` grammar."""

    def __init__( self, parser, nonterm ):
        NonTerminal.__init__( self, parser, nonterm )
        self._nonterms = (self.nonterm,) = (nonterm,)
        # Set parent attribute for children, should be last statement !!
        self.setparent( self, self.children() )

    def children( self ):
        return self._nonterms

    def show( self, buf=sys.stdout, offset=0, attrnames=False,
              showcoord=False ):
        lead = ' ' * offset
        buf.write( lead + 'prolog: ' )
        if showcoord:
            buf.write( ' (at %s)' % self.coord )
        buf.write('\n')
        [ x.show(buf, offset+2, attrnames, showcoord) for x in self.children() ]


class Siblings( NonTerminal ):
    """class to handle `siblings` grammar."""

    def __init__( self, parser, siblings, sibling ) :
        NonTerminal.__init__( self, parser, siblings, siblings )
        self._nonterms = self.siblings, self.sibling = siblings, sibling
        self._nonterms = filter( None, self._nonterms )
        # Set parent attribute for children, should be last statement !!
        self.setparent( self, self.children() )

    def children( self ):
        return self._nonterms

    def preprocess( self, igen ) :
        [ x.preprocess( igen ) for x in self.flatten() ]

    def generate( self, igen, *args, **kwargs ) :
        [ x.generate( igen, *args, **kwargs ) for x in self.flatten() ]

    def dump( self, context ) :
        return ''.join([ x.dump(context) for x in self.flatten() ])

    def show( self, buf=sys.stdout, offset=0, attrnames=False,
              showcoord=False ):
        if showcoord:
            buf.write( ' (at %s)' % self.coord )
        [ x.show(buf, offset, attrnames, showcoord) for x in self.flatten() ]

    def flatten( self ) :
        return NonTerminal.flatten( self, 'siblings', 'sibling' )


class Sibling( NonTerminal ):
    """class to handle `sibling` grammar."""

    def __init__( self, parser, nonterm ) :
        NonTerminal.__init__( self, parser, nonterm )
        self._nonterms = (self.nonterm,) = (nonterm,)
        # Set parent attribute for children, should be last statement !!
        self.setparent( self, self.children() )

    def children( self ):
        return self._nonterms

    def generate( self, igen, *args, **kwargs ):
        NonTerminal.generate( self, igen, *args, **kwargs )

    def show( self, buf=sys.stdout, offset=0, attrnames=False,
              showcoord=False ):
        lead = ' ' * offset
        buf.write( lead + 'sibling: ' )
        if showcoord:
            buf.write( ' (at %s)' % self.coord )
        buf.write('\n')
        [ x.show(buf, offset+2, attrnames, showcoord) for x in self.children() ]


#---- Prologs

class DocType( NonTerminal ):
    """class to handle `doctype` grammar.
        !!! <doc> <ver> <type>
    """

    def __init__( self, parser, doctype ) :
        NonTerminal.__init__( self, parser, doctype )
        self._terms = (self.DOCTYPE,) = (doctype,)
        # Set parent attribute for children, should be last statement !!
        self.setparent( self, self.children() )

    def preprocess( self, igen ):
        from   tayra.ttl.doctype    import ttl2doctype
        self.html = ttl2doctype( self.DOCTYPE.dump(None) )

    def generate( self, igen, *args, **kwargs ) :
        self.bubbleupaccum( 'doctypes', self.html )

    def children( self ):
        return self._terms

    def show( self, buf=sys.stdout, offset=0, attrnames=False,
              showcoord=False ):
        lead = ' ' * offset
        buf.write( lead + 'doctype: ' )
        if showcoord:
            buf.write( ' (at %s)' % self.coord )
        buf.write('\n')
        [ x.show(buf, offset+2, attrnames, showcoord) for x in self.children() ]


class Body( NonTerminal ):
    """class to handle `body` grammar."""

    def __init__( self, parser, body ) :
        NonTerminal.__init__( self, parser, body )
        self._terms = (self.BODY,) = (body,)
        # Set parent attribute for children, should be last statement !!
        self.setparent( self, self.children() )

    def children( self ):
        return self._terms

    def preprocess( self, igen ):
        self.signature = self.BODY.dump(None)[5:].strip(' \t\r\n').rstrip(';')
        self.bubbleup( 'bodysignature', self.signature )

    def generate( self, igen, *args, **kwargs ):
        pass

    def show( self, buf=sys.stdout, offset=0, attrnames=False,
              showcoord=False ):
        lead = ' ' * offset
        buf.write( lead + 'body: ' )
        if showcoord:
            buf.write( ' (at %s)' % self.coord )
        buf.write('\n')
        [ x.show(buf, offset+2, attrnames, showcoord) for x in self.children() ]


class ImportAs( NonTerminal ):
    """class to handle `importas` grammar."""

    def __init__( self, parser, importas ) :
        NonTerminal.__init__( self, parser, importas )
        self._terms = (self.IMPORTAS,) = (importas,)
        # Set parent attribute for children, should be last statement !!
        self.setparent( self, self.children() )

    def _parseline( self, line ):
        parts = ' '.join( line.splitlines() ).split(' ')
        ttlloc, modname = parts[1], parts[3]
        return ttlloc, modname

    def children( self ):
        return self._terms

    def generate( self, igen, *args, **kwargs ):
        line = self.IMPORTAS.dump(None).rstrip(';\r\n')
        ttlloc, modname = self._parseline( line )
        igen.putimport( ttlloc, modname )

    def show( self, buf=sys.stdout, offset=0, attrnames=False,
              showcoord=False ):
        lead = ' ' * offset
        buf.write( lead + 'importas: ' )
        if showcoord:
            buf.write( ' (at %s)' % self.coord )
        buf.write('\n')
        [ x.show(buf, offset+2, attrnames, showcoord) for x in self.children() ]


class Inherit( NonTerminal ):
    """class to handle `inherit` grammar."""

    def __init__( self, parser, inherit ) :
        NonTerminal.__init__( self, parser, inherit )
        self._terms = (self.INHERIT,) = (inherit,)
        # Set parent attribute for children, should be last statement !!
        self.setparent( self, self.children() )

    def _parseline( self, line ):
        parts = ' '.join( line.splitlines() ).split(' ')
        ttlloc = parts[1]
        return ttlloc

    def children( self ):
        return self._terms

    def generate( self, igen, *args, **kwargs ):
        line = self.INHERIT.dump(None).rstrip(';\r\b')
        ttlloc = self._parseline( line )
        igen.putinherit( ttlloc )

    def show( self, buf=sys.stdout, offset=0, attrnames=False,
              showcoord=False ):
        lead = ' ' * offset
        buf.write( lead + 'inherit: ' )
        if showcoord:
            buf.write( ' (at %s)' % self.coord )
        buf.write('\n')
        [ x.show(buf, offset+2, attrnames, showcoord) for x in self.children() ]


class Implement( NonTerminal ):
    """class to handle `implement` grammar."""

    def __init__( self, parser, implement ) :
        NonTerminal.__init__( self, parser, implement )
        self._terms = (self.IMPLEMENT,) = (implement,)
        # Set parent attribute for children, should be last statement !!
        self.setparent( self, self.children() )

    def _parseline( self, line ):
        parts = ' '.join( line.splitlines() ).split(' ')
        interface, pluginname = parts[1], parts[3]
        return interface, name

    def children( self ):
        return self._terms

    def preprocess( self, igen ):
        line = self.IMPLEMENT.dump(None).rstrip(';\r\n')
        interface, pluginname = self._parseline( line )
        self.importinterface( interface )
        self.bubbleupaccum( 'implements', (interface, pluginname) )

    def show( self, buf=sys.stdout, offset=0, attrnames=False,
              showcoord=False ):
        lead = ' ' * offset
        buf.write( lead + 'implement: ' )
        if showcoord:
            buf.write( ' (at %s)' % self.coord )
        buf.write('\n')
        [ x.show(buf, offset+2, attrnames, showcoord) for x in self.children() ]


class Use( NonTerminal ):
    """class to handle `use` grammar."""

    def __init__( self, parser, use ) :
        NonTerminal.__init__( self, parser, use )
        self._terms = (self.USE,) = (use,)
        # Set parent attribute for children, should be last statement !!
        self.setparent( self, self.children() )

    def _parseline( self, line ):
        parts = ' '.join( line.splitlines() ).split(' ')
        if len(parts) == 5 and (parts[0], parts[3]) == ('@use', 'as') :
            interface, pluginname, importname = parts[1], parts[2], parts[4]
        elif len(parts) == 4 and (parts[0], parts[2]) == ('@use', 'as') :
            interface, pluginname, importname = parts[1], '', parts[3]
        return interface, pluginname, importname

    def children( self ):
        return self._terms

    def preprocess( self, igen ):
        line = self.USE.dump(None).rstrip(';\r\n')
        interface, pluginname, importname = self._parseline( line )

    def show( self, buf=sys.stdout, offset=0, attrnames=False,
              showcoord=False ):
        lead = ' ' * offset
        buf.write( lead + 'use: ' )
        if showcoord:
            buf.write( ' (at %s)' % self.coord )
        buf.write('\n')
        [ x.show(buf, offset+2, attrnames, showcoord) for x in self.children() ]


#---- Template blocks (root-level)

class InterfaceBlock( NonTerminal ):
    """class to handle `interfaceblock` grammar."""

    def __init__( self, parser, interface, indent, siblings, dedent ) :
        NonTerminal.__init__( self, parser, interface, indent, siblings, dedent )
        self._terms = self.INTERFACE, self.INDENT, self.DEDENT = \
                interface, indent, dedent
        self._nonterms = (self.siblings,) = (siblings,)
        self._terms = filter( None, self._terms )
        self._nonterms = filter( None, self._nonterms )
        # Set parent attribute for children, should be last statement !!
        self.setparent( self, self.children() )

    def children( self ):
        return (self.INTERFACE, self.INDENT, self.siblings, self.DEDENT)

    def generate( self, igen, *args, **kwargs ):
        igen.pushbuf()
        line = ' '.join( self.INTERFACE.dump(None)[10:].splitlines() )
        interfacename, signature = line.split(' ', 1)[0]
        interface, method = interfacename.rsplit('.', 1)
        funcline = 'def ' + method + signature
        self.gencontrolblock( igen, funcline, *args, **kwargs )
        igen.cr()
        self.bubbleupaccum( 'interfaces', (interface, method) )
        igen.popreturn( astext=True )
        return None

    def dump( self, context ) :
        text = self.INTERFACE.dump(context)
        if self.siblings :
            context.htmlindent += self.INDENT.dump(context)
            text += self.siblings.dump(context)
            context.htmlindent = context.htmlindent[:-len(self.DEDENT.terminal)]
        return text

    def show( self, buf=sys.stdout, offset=0, attrnames=False,
              showcoord=False ):
        lead = ' ' * offset
        buf.write( lead + 'interfaceblock: ' )
        if showcoord:
            buf.write( ' (at %s)' % self.coord )
        buf.write('\n')
        [ x.show(buf, offset+2, attrnames, showcoord) for x in self.children() ]


#---- Template blocks (nested)

class TagBlock( NonTerminal ):
    """class to handle `tagblock` grammar."""

    def __init__( self, parser, tagline, indent, siblings, dedent ) :
        NonTerminal.__init__( self, parser, tagline, indent, siblings, dedent )
        self._terms = self.INDENT, self.DEDENT = indent, dedent
        self._nonterms = self.tagline, self.siblings = tagline, siblings
        # Set parent attribute for children, should be last statement !!
        self.setparent( self, self.children() )

    def children( self ):
        return (self.tagline, self.INDENT, self.siblings, self.DEDENT)

    def generate( self, igen, *args, **kwargs ):
        self.tagline.generate(igen, *args, **kwargs)
        igen.upindent( up=self.INDENT.dump(None) )
        self.siblings.generate( igen, *args, **kwargs )
        igen.downindent( down=self.DEDENT.dump(None) )
        tag = self.tagline.tag
        if tag.TAGCLOSE :
            igen.indent()
            igen.puttext( tag.closetag(igen) + '\n' )
        return None

    def dump( self, context ) :
        text = self.tagline.dump(context)
        context.htmlindent += self.INDENT.dump(context)
        text += self.siblings.dump(context)
        context.htmlindent = context.htmlindent[:-len(self.DEDENT.terminal)]
        return text

    def show( self, buf=sys.stdout, offset=0, attrnames=False,
              showcoord=False ):
        lead = ' ' * offset
        buf.write( lead + 'tagblock: ' )
        if showcoord:
            buf.write( ' (at %s)' % self.coord )
        buf.write('\n')
        [ x.show(buf, offset+2, attrnames, showcoord) for x in self.children() ]


class FilterBlock( NonTerminal ):
    """class to handle `filterblock` grammar."""

    def __init__( self, parser, filter_, indent, filterlines, dedent ) :
        NonTerminal.__init__( self, parser, filter_, indent, filterlines, dedent )
        self._terms = self.FILTER, self.INDENT, self.DEDENT = \
                filter_, indent, dedent
        self._nonterms = (self.filterlines,) = (filterlines,)
        # Set parent attribute for children, should be last statement !!
        self.setparent( self, self.children() )

    def children( self ):
        return (self.FILTER, self.INDENT, self.filterlines, self.DEDENT)

    # TODO : Yet to complete
    def generate( self, igen, *args, **kwargs ):
        line = ' '.join( self.FILTER.dump(None).splitlines() )
        parts = line.split(' ', 1)[0]
        return None

    def dump( self, context ) :
        text = self.FILTER.dump(context)
        context.htmlindent += self.INDENT.dump(context)
        text += self.filterlines.dump(context)
        context.htmlindent = context.htmlindent[:-len(self.DEDENT.terminal)]
        return text

    def show( self, buf=sys.stdout, offset=0, attrnames=False,
              showcoord=False ):
        lead = ' ' * offset
        buf.write( lead + 'filterblock: ' )
        if showcoord:
            buf.write( ' (at %s)' % self.coord )
        buf.write('\n')
        [ x.show(buf, offset+2, attrnames, showcoord) for x in self.children() ]


class FunctionBlock( NonTerminal ):
    """class to handle `functionblock` grammar."""

    def __init__( self, parser, function, indent, siblings, dedent ) :
        NonTerminal.__init__( self, parser, function, indent, siblings, dedent )
        self._terms = self.FUNCTION, self.INDENT, self.DEDENT = \
                function, indent, dedent
        self._nonterms = (self.siblings,) = (siblings,)
        self._terms = filter( None, self._terms )
        self._nonterms = filter( None, self._nonterms )
        # Set parent attribute for children, should be last statement !!
        self.setparent( self, self.children() )

    def children( self ):
        x = (self.FUNCTION, self.INDENT, self.siblings, self.DEDENT)
        return filter( None, x )

    def generate( self, igen, *args, **kwargs ):
        igen.pushbuf()
        line = self.FUNCTION.dump(None)
        line = ' '.join( line.replace( '@function', 'def' ).splitlines() )
        self.gencontrolblock( igen, line, *args, **kwargs )
        igen.cr()
        igen.popreturn( astext=True )
        return None

    def dump( self, context ) :
        text = self.FUNCTION.dump(context)
        if self.siblings :
            context.htmlindent += self.INDENT.dump(context)
            text += self.siblings.dump(context)
            context.htmlindent = context.htmlindent[:-len(self.DEDENT.terminal)]
        return text

    def show( self, buf=sys.stdout, offset=0, attrnames=False,
              showcoord=False ):
        lead = ' ' * offset
        buf.write( lead + 'functionblock: ' )
        if showcoord:
            buf.write( ' (at %s)' % self.coord )
        buf.write('\n')
        [ x.show(buf, offset+2, attrnames, showcoord) for x in self.children() ]


#---- Control Blocks


class IfelfiBlock( NonTerminal ):
    """class to handle `ifelfiblock` grammar."""

    def __init__( self, parser, ifelfiblock, ifblock, elifblock, elseblock ) :
        NonTerminal.__init__(self, parser, ifelfiblock, ifblock, elifblock, elseblock)
        self._nonterms = \
            self.ifelfiblock, self.ifblock, self.elifblock, self.elseblock = \
                ifelfiblock, ifblock, elifblock, elseblock
        # Set parent attribute for children, should be last statement !!
        self.setparent( self, self.children() )

    def children( self ):
        return self._nonterms

    def show( self, buf=sys.stdout, offset=0, attrnames=False,
              showcoord=False ):
        lead = ' ' * offset
        buf.write( lead + 'ifelfiblock: ' )
        if showcoord:
            buf.write( ' (at %s)' % self.coord )
        buf.write('\n')
        [ x.show(buf, offset+2, attrnames, showcoord) for x in self.children() ]


class IfBlock( NonTerminal ):
    """class to handle `ifblock` grammar."""

    def __init__( self, parser, ifterm, indent, siblings, dedent ) :
        NonTerminal.__init__( self, parser, ifterm, indent, siblings, dedent )
        self._terms = self.IF, self.INDENT, self.DEDENT = \
                    ifterm, indent, dedent
        self._nonterms = (self.siblings,) = (siblings,)
        # Set parent attribute for children, should be last statement !!
        self.setparent( self, self.children() )

    def children( self ):
        return (self.IF, self.INDENT, self.siblings, self.DEDENT)

    def generate( self, igen, *args, **kwargs ):
        line = self.IF.dump(None)
        line = ' '.join( line.replace( '@if', 'if' ).splitlines() )
        self.gencontrolblock( igen, line, '', *args, **kwargs )
        return None

    def dump( self, context ) :
        text = self.IF.dump(context)
        context.htmlindent += self.INDENT.dump(context)
        text += self.siblings.dump(context)
        context.htmlindent = context.htmlindent[:-len(self.DEDENT.terminal)]
        return text

    def show( self, buf=sys.stdout, offset=0, attrnames=False,
              showcoord=False ):
        lead = ' ' * offset
        buf.write( lead + 'ifblock: ' )
        if showcoord:
            buf.write( ' (at %s)' % self.coord )
        buf.write('\n')
        [ x.show(buf, offset+2, attrnames, showcoord) for x in self.children() ]


class ElifBlock( NonTerminal ):
    """class to handle `elifblock` grammar."""

    def __init__( self, parser, elifterm, indent, siblings, dedent ) :
        NonTerminal.__init__( self, parser, elifterm, indent, siblings, dedent )
        self._terms = self.ELIF, self.INDENT, self.DEDENT = \
                    elifterm, indent, dedent
        self._nonterms = (self.siblings,) = (siblings,)
        # Set parent attribute for children, should be last statement !!
        self.setparent( self, self.children() )

    def children( self ):
        return (self.ELIF, self.INDENT, self.siblings, self.DEDENT)

    def generate( self, igen, *args, **kwargs ):
        line = self.ELIF.dump(None)
        line = ' '.join( line.replace( '@elif', 'elif' ).splitlines() )
        self.gencontrolblock( igen, line, '', *args, **kwargs )
        return None

    def dump( self, context ) :
        text = self.ELIF.dump(context)
        context.htmlindent += self.INDENT.dump(context)
        text += self.siblings.dump(context)
        context.htmlindent = context.htmlindent[:-len(self.DEDENT.terminal)]
        return text

    def show( self, buf=sys.stdout, offset=0, attrnames=False,
              showcoord=False ):
        lead = ' ' * offset
        buf.write( lead + 'elifblock: ' )
        if showcoord:
            buf.write( ' (at %s)' % self.coord )
        buf.write('\n')
        [ x.show(buf, offset+2, attrnames, showcoord) for x in self.children() ]


class ElseBlock( NonTerminal ):
    """class to handle `elseblock` grammar."""

    def __init__( self, parser, elseterm, indent, siblings, dedent ) :
        NonTerminal.__init__( self, parser, elseterm, indent, siblings, dedent )
        self._terms = self.ELSE, self.INDENT, self.DEDENT = \
                elseterm, indent, dedent
        self._nonterms = (self.siblings,) = (siblings,)
        # Set parent attribute for children, should be last statement !!
        self.setparent( self, self.children() )

    def children( self ):
        return (self.ELSE, self.INDENT, self.siblings, self.DEDENT)

    def generate( self, context, *args, **kwargs ):
        line = self.ELSE.dump(None)
        line = ' '.join( line.replace( '@else', 'else' ).splitlines() )
        self.gencontrolblock( igen, line, '', *args, **kwargs )
        return None

    def dump( self, context ) :
        text = self.ELSE.dump(context)
        context.htmlindent += self.INDENT.dump(context)
        text += self.siblings.dump(context)
        context.htmlindent = context.htmlindent[:-len(self.DEDENT.terminal)]
        return text

    def show( self, buf=sys.stdout, offset=0, attrnames=False,
              showcoord=False ):
        lead = ' ' * offset
        buf.write( lead + 'elseblock: ' )
        if showcoord:
            buf.write( ' (at %s)' % self.coord )
        buf.write('\n')
        [ x.show(buf, offset+2, attrnames, showcoord) for x in self.children() ]


class ForBlock( NonTerminal ):
    """class to handle `elseblock` grammar."""

    def __init__( self, parser, forterm, indent, siblings, dedent ) :
        NonTerminal.__init__( self, parser, forterm, indent, siblings, dedent )
        self._terms = self.FOR, self.INDENT, self.DEDENT = \
                forterm, indent, dedent
        self._nonterms = (self.siblings,) = (siblings,)
        # Set parent attribute for children, should be last statement !!
        self.setparent( self, self.children() )

    def children( self ):
        return (self.FOR, self.INDENT, self.siblings, self.DEDENT)

    def generate( self, igen, *args, **kwargs ):
        line = self.FOR.dump(None)
        line = ' '.join( line.replace( '@for', 'for' ).splitlines() )
        self.gencontrolblock( igen, line, '', *args, **kwargs )
        return None

    def dump( self, context ) :
        text = self.tagline.dump(context)
        context.htmlindent += self.INDENT.dump(context)
        text += self.siblings.dump(context)
        context.htmlindent = context.htmlindent[:-len(self.DEDENT.terminal)]
        return text

    def show( self, buf=sys.stdout, offset=0, attrnames=False,
              showcoord=False ):
        lead = ' ' * offset
        buf.write( lead + 'forblock: ' )
        if showcoord:
            buf.write( ' (at %s)' % self.coord )
        buf.write('\n')
        [ x.show(buf, offset+2, attrnames, showcoord) for x in self.children() ]


class WhileBlock( NonTerminal ):
    """class to handle `whileblock` grammar."""

    def __init__( self, parser, whileterm, indent, siblings, dedent ) :
        NonTerminal.__init__( self, parser, whileterm, indent, siblings, dedent )
        self._terms = self.WHILE, self.INDENT, self.DEDENT = \
                whileterm, indent, dedent
        self._nonterms = (self.siblings,) = (siblings,)
        # Set parent attribute for children, should be last statement !!
        self.setparent( self, self.children() )

    def children( self ):
        return (self.WHILE, self.INDENT, self.siblings, self.DEDENT)

    def generate( self, igen, *args, **kwargs ):
        line = self.WHILE.dump(None)
        line = ' '.join( line.replace( '@while', 'while' ).splitlines() )
        self.gencontrolblock( igen, line, '', *args, **kwargs )
        return None

    def dump( self, context ) :
        text = self.WHILE.dump(context)
        context.htmlindent += self.INDENT.dump(context)
        text += self.siblings.dump(context)
        context.htmlindent = context.htmlindent[:-len(self.DEDENT.terminal)]
        return text

    def show( self, buf=sys.stdout, offset=0, attrnames=False,
              showcoord=False ):
        lead = ' ' * offset
        buf.write( lead + 'whileblock: ' )
        if showcoord:
            buf.write( ' (at %s)' % self.coord )
        buf.write('\n')
        [ x.show(buf, offset+2, attrnames, showcoord) for x in self.children() ]


#---- Template lines (nested)

class Statement( NonTerminal ):
    """class to handle `statement` grammar."""

    def __init__( self, parser, statement ) :
        NonTerminal.__init__( self, parser, statement )
        self._terms = (self.STATEMENT,) = (statement,)
        # Set parent attribute for children, should be last statement !!
        self.setparent( self, self.children() )

    def children( self ):
        return self._terms

    def generate( self, igen, *args, **kwargs ):
        text = self.STATEMENT.dump(None).lstrip(' \t$')
        igen.putstatement( text )

    def dump( self, context ) :
        return context.htmlindent + NonTerminal.dump( self, context )

    def show( self, buf=sys.stdout, offset=0, attrnames=False,
              showcoord=False ):
        lead = ' ' * offset
        buf.write( lead + 'statement: ' )
        if showcoord:
            buf.write( ' (at %s)' % self.coord )
        buf.write('\n')
        [ x.show(buf, offset+2, attrnames, showcoord) for x in self.children() ]


class TagLine( NonTerminal ):
    """class to handle `tagline` grammar."""

    def __init__( self, parser, tag, content, newlines ) :
        NonTerminal.__init__( self, parser, tag, content, newlines )
        self._nonterms = self.tag, self.content = tag, content
        self._nonterms = filter( None, self._nonterms )
        self._terms = (self.NEWLINES,) = (newlines,)
        # Set parent attribute for children, should be last statement !!
        self.setparent( self, self.children() )

    def children( self ):
        return self._nonterms + self._terms

    def generate( self, igen, *args, **kwargs ):
        igen.comment( self.dump( Context() ))
        igen.indent()
        # Generate tag
        children = filter( None, [self.tag, self.content] )
        [ x.generate( igen, *args, **kwargs ) for x in children ]
        # Generate closing tag
        if isinstance( self.parent, Sibling ) and self.tag.TAGCLOSE :
            igen.puttext( self.tag.closetag(igen) )
        self.NEWLINES and self.NEWLINES.generate( igen, *args, **kwargs )

    def dump( self, context ) :
        return context.htmlindent + NonTerminal.dump( self, context )

    def show( self, buf=sys.stdout, offset=0, attrnames=False,
              showcoord=False ):
        lead = ' ' * offset
        buf.write( lead + 'tagline: ' )
        if showcoord:
            buf.write( ' (at %s)' % self.coord )
        buf.write('\n')
        [ x.show(buf, offset+2, attrnames, showcoord) for x in self.children() ]


class TextBlock( NonTerminal ):
    """class to handle `textblock` grammar."""

    def __init__( self, parser, textblock1, textline,
                  indent, textblock2, dedent ) :
        NonTerminal.__init__(
            self, parser, textblock1, textline, indent, textblock2, dedent )
        self._nonterms = self.textblock1, self.textline, self.textblock2 = \
                textblock1, textline, textblock2
        self._terms = self.INDENT, self.DEDENT = indent, dedent
        self._nonterms = filter( None, self._nonterms )
        self._terms = filter( None, self._terms )
        # Set parent attribute for children, should be last statement !!
        self.setparent( self, self.children() )

    def children( self ):
        x = ( self.textblock1, self.textline, self.INDENT, self.textblock2,
              self.DEDENT )
        return filter( None, x )

    def generate( self, igen, *args, **kwargs ):
        if self.INDENT : igen.upindent()
        [ x.generate( igen, *args, **kwargs ) for x in self.flatten() ]
        if self.DEDENT : igen.downindent()

    def dump( self, context ) :
        if self.INDENT : context.htmlindent + self.INDENT
        text = ''.join([ x.dump( context ) for x in self.flatten() ])
        if self.DEDENT : context.htmlindent + self.INDENT
        return text

    def show( self, buf=sys.stdout, offset=0, attrnames=False,
              showcoord=False ):
        lead = ' ' * offset
        buf.write( lead + 'textline: ' )
        if showcoord:
            buf.write( ' (at %s)' % self.coord )
        buf.write('\n')
        [ x.show(buf, offset+2, attrnames, showcoord) for x in self.children() ]

    def flatten( self ) :
        blocks = lambda n :filter( None, [ n.textblock1, n.textblock2 ])
        textblocks = [ self ]
        textlines = []
        while textblocks :
            node = textblocks.pop(-1)
            textlines.append( node.textline ) if node.textline else None
            textblocks = textblocks + blocks(node)
        textlines.reverse()
        return textlines


class TextLine( NonTerminal ):
    """class to handle `textline` grammar."""

    def __init__( self, parser, contents, newlines ) :
        NonTerminal.__init__( self, parser, contents )
        self._nonterms = (self.contents,) = (contents,)
        self._terms = (self.NEWLINES,) = (newlines,)
        # Set parent attribute for children, should be last statement !!
        self.setparent( self, self.children() )

    def children( self ):
        return self._nonterms + self._terms

    def generate( self, igen, *args, **kwargs ):
        igen.indent()
        igen.comment( self.dump( Context() ))
        NonTerminal.generate( self, igen, *args, **kwargs )

    def dump( self, context ) :
        return context.htmlindent + NonTerminal.dump( self, context )

    def show( self, buf=sys.stdout, offset=0, attrnames=False,
              showcoord=False ):
        lead = ' ' * offset
        buf.write( lead + 'textline: ' )
        if showcoord:
            buf.write( ' (at %s)' % self.coord )
        buf.write('\n')
        [ x.show(buf, offset+2, attrnames, showcoord) for x in self.children() ]


#---- Tags


class Tag( NonTerminal ):
    """class to handle `tag` grammar."""

    def __init__( self, parser, tagopen, specifiers, style, attributes,
                  tagend, tagclose ) :
        NonTerminal.__init__(
            self, parser, tagopen, specifiers, style, attributes, tagend
        )
        self._terms = \
            self.TAGOPEN, self.TAGEND, self.TAGCLOSE = tagopen, tagend, tagclose
        self._nonterms = self.specifiers, self.style, self.attributes = \
            specifiers, style, attributes
        self._terms = filter( None, self._terms )
        self._nonterms = filter( None, self._nonterms )
        # Set parent attribute for children, should be last statement !!
        self.setparent( self, self.children() )

    def children( self ):
        x = ( self.TAGOPEN, self.specifiers, self.style, self.attributes,
              self.TAGEND, self.TAGCLOSE )
        return filter( None, x )

    def generate( self, igen, *args, **kwargs ):
        igen.pushbuf()

        self.TAGOPEN.generate(igen, *args, **kwargs)
        items = [ (self.specifiers,True), (self.style,True),
                  (self.attributes,False) ]
        for item, astext in items :
            if item :
                compute = lambda : item.generate(igen, *args, **kwargs);
                self.stackcompute( igen, compute, astext=astext )
            else :
                igen.puttext( '' )
        self.TAGEND and self.TAGEND.generate(igen, *args, **kwargs)
        self.TAGCLOSE and self.TAGCLOSE.generate(igen, *args, **kwargs)

        igen.computetag()

    def closetag( self, igen ):
        tagname = self.TAGOPEN.dump(None)[1:].rstrip(' ')
        return '</%s>' % tagname

    def show( self, buf=sys.stdout, offset=0, attrnames=False,
              showcoord=False ):
        lead = ' ' * offset
        buf.write( lead + 'tag: ' )
        if showcoord:
            buf.write( ' (at %s)' % self.coord )
        buf.write('\n')
        [ x.show(buf, offset+2, attrnames, showcoord) for x in self.children() ]

#---- Attributes

class Attributes( NonTerminal ):
    """class to handle `attributes` grammar."""

    def __init__( self, parser, attributes, whitespace, attr ) :
        NonTerminal.__init__( self, parser, attributes, whitespace, attr )
        self._nonterms = self.attributes, self.whitespace, self.attribute = \
                attributes, whitespace, attr
        self._nonterms = filter( None, self._nonterms )
        # Set parent attribute for children, should be last statement !!
        self.setparent( self, self.children() )

    def children( self ):
        return self._nonterms

    def generate( self, igen, *args, **kwargs ) :
        for attr in self.flatten() :
            compute = lambda : attr.generate( igen, *args, **kwargs )
            self.stackcompute( igen, compute, astext=True )

    def show( self, buf=sys.stdout, offset=0, attrnames=False,
              showcoord=False ):
        lead = ' ' * offset
        buf.write( lead + 'attributes: ' )
        if showcoord:
            buf.write( ' (at %s)' % self.coord )
        buf.write('\n')
        [ x.show(buf, offset+2, attrnames, showcoord) for x in self.children() ]

    def flatten( self ) :
        return NonTerminal.flatten( self, 'attributes', 'attribute' )



class Attr( NonTerminal ):
    """class to handle `attr` grammar."""

    def __init__( self, parser, attrname, smartstring ) :
        NonTerminal.__init__( self, parser, attrname, smartstring )
        self._nonterms = self.attrname, self.smartstring = attrname, smartstring
        # Set parent attribute for children, should be last statement !!
        self.setparent( self, self.children() )

    def children( self ):
        return self._nonterms

    def show( self, buf=sys.stdout, offset=0, attrnames=False,
              showcoord=False ):
        lead = ' ' * offset
        buf.write( lead + 'attr: ' )
        if showcoord:
            buf.write( ' (at %s)' % self.coord )
        buf.write('\n')
        [ x.show(buf, offset+2, attrnames, showcoord) for x in self.children() ]


class AttrName( NonTerminal ):
    """class to handle `attr` grammar."""

    def __init__( self, parser, atom, equal ) :
        NonTerminal.__init__( self, parser, atom, equal )
        self._terms = (self.ATOM, self.EQUAL) = (atom, equal)
        # Set parent attribute for children, should be last statement !!
        self.setparent( self, self.children() )

    def children( self ):
        return self._terms

    def show( self, buf=sys.stdout, offset=0, attrnames=False,
              showcoord=False ):
        lead = ' ' * offset
        buf.write( lead + 'attrname: ' )
        if showcoord:
            buf.write( ' (at %s)' % self.coord )
        buf.write('\n')
        [ x.show(buf, offset+2, attrnames, showcoord) for x in self.children() ]


#---- Common ASTs

class Contents( NonTerminal ):
    """class to handle `contents` grammar."""

    def __init__( self, parser, contents, content ) :
        NonTerminal.__init__( self, parser, contents, content )
        self._nonterms = self.contents, self.content = contents, content
        self._nonterms = filter( None, self._nonterms )
        # Set parent attribute for children, should be last statement !!
        self.setparent( self, self.flatten() )

    def children( self ):
        return self._nonterms

    def generate( self, igen, *args, **kwargs ):
        [ x.generate( igen, *args, **kwargs ) for x in self.flatten() ]

    def show( self, buf=sys.stdout, offset=0, attrnames=False,
              showcoord=False ):
        lead = ' ' * offset
        buf.write( lead + 'contents: ' )
        if showcoord:
            buf.write( ' (at %s)' % self.coord )
        buf.write('\n')
        [ x.show(buf, offset+2, attrnames, showcoord) for x in self.flatten() ]

    def flatten( self ) :
        return NonTerminal.flatten( self, 'contents', 'content' )


class Content( NonTerminal ):
    """class to handle `content` grammar."""

    def __init__( self, parser, term, exprs ) :
        NonTerminal.__init__( self, parser, term, exprs )
        self._terms = (self.TERM,) = (term,)
        self._nonterms = (self.exprs,) = (exprs,)
        self._terms = filter( None, self._terms )
        self._nonterms = filter( None, self._nonterms )
        # Set parent attribute for children, should be last statement !!
        self.setparent( self, self.children() )

    def children( self ):
        return self._terms + self._nonterms

    def show( self, buf=sys.stdout, offset=0, attrnames=False,
              showcoord=False ):
        lead = ' ' * offset
        buf.write( lead + 'content: ' )
        if showcoord:
            buf.write( ' (at %s)' % self.coord )
        buf.write('\n')
        [ x.show(buf, offset+2, attrnames, showcoord) for x in self.children() ]

#---- Specifiers

class Specifiers( NonTerminal ):
    """class to handle `specifiers` grammar."""

    def __init__( self, parser, specifiers, whitespace, specifier ) :
        NonTerminal.__init__( self, parser, specifiers, whitespace, specifier )
        self._nonterms = self.specifiers, self.whitespace, self.specifier = \
                specifiers, whitespace, specifier
        self._nonterms = filter( None, self._nonterms )
        # Set parent attribute for children, should be last statement !!
        self.setparent( self, self.children() )

    def children( self ):
        return self._nonterms

    def show( self, buf=sys.stdout, offset=0, attrnames=False,
              showcoord=False ):
        lead = ' ' * offset
        buf.write( lead + 'specifiers: ' )
        if showcoord:
            buf.write( ' (at %s)' % self.coord )
        buf.write('\n')
        [ x.show(buf, offset+2, attrnames, showcoord) for x in self.children() ]

    def flatten( self ) :
        return NonTerminal.flatten( self, 'specifiers', 'specifier' )


class Specifier( NonTerminal ):
    """class to handle `specifier` grammar."""

    def __init__( self, parser, atom, smartstring, exprs ) :
        NonTerminal.__init__( self, parser, atom, smartstring, exprs )
        self._terms = (self.ATOM,) = (atom,)
        self._nonterms = self.smartstring, self.exprs = smartstring, exprs
        self._terms = filter( None, self._terms )
        self._nonterms = filter( None, self._nonterms )
        # Set parent attribute for children, should be last statement !!
        self.setparent( self, self.children() )

    def children( self ):
        return self._terms + self._nonterms

    def show( self, buf=sys.stdout, offset=0, attrnames=False,
              showcoord=False ):
        lead = ' ' * offset
        buf.write( lead + 'specifier: ' )
        if showcoord:
            buf.write( ' (at %s)' % self.coord )
        buf.write('\n')
        [ x.show(buf, offset+2, attrnames, showcoord) for x in self.children() ]

#---- SmartString

class SmartString( NonTerminal ):
    """class to handle `smartstring` grammar."""

    def __init__( self, parser, quote1, strcontents, quote2 ) :
        NonTerminal.__init__( self, parser, quote1, strcontents, quote2 )
        self._terms = self.QUOTE1, self.QUOTE2 = quote1, quote2
        self._nonterms = (self.strcontents,) = (strcontents,)
        self._nonterms = filter( None, self._nonterms )
        # Set parent attribute for children, should be last statement !!
        self.setparent( self, self.children() )

    def children( self ):
        x = ( self.QUOTE1, self.strcontents, self.QUOTE2 )
        return filter( None, x )

    def generate( self, igen, *args, **kwargs ):
        if self.strcontents :
            compute = lambda: [ 
                x.generate(igen, *args, **kwargs) for x in self.children()
            ]
            self.stackcompute( igen, compute, astext=True )
        return None

    def show( self, buf=sys.stdout, offset=0, attrnames=False,
              showcoord=False ):
        lead = ' ' * offset
        buf.write( lead + 'smartstring: ' )
        if showcoord:
            buf.write( ' (at %s)' % self.coord )
        buf.write('\n')
        [ x.show(buf, offset+2, attrnames, showcoord) for x in self.children() ]


class StrContents( NonTerminal ):
    """class to handle `strcontents` grammar."""

    def __init__( self, parser, strcontents, strcontent ) :
        NonTerminal.__init__( self, parser, strcontents, strcontent )
        self._nonterms = self.strcontents, self.strcontent = \
                strcontents, stsrcontent
        self._nonterms = filter( None, self._nonterms )
        # Set parent attribute for children, should be last statement !!
        self.setparent( self, self.children() )

    def children( self ):
        return self._nonterms

    def generate( self, igen, *args, **kwargs ):
        contents = self.flatten()
        for cont in contents :
            if isinstance(cont, Exprs) :
                igen.puttext(text); cont.generate( igen, *args, **kwargs );
                text = ''
            else :
                text += cont.dump( Context() )
        text and igen.puttext(text)

    def show( self, buf=sys.stdout, offset=0, attrnames=False,
              showcoord=False ):
        lead = ' ' * offset
        buf.write( lead + 'strcontents: ' )
        if showcoord:
            buf.write( ' (at %s)' % self.coord )
        buf.write('\n')
        [ x.show(buf, offset+2, attrnames, showcoord) for x in self.children() ]

    def flatten( self ) :
        return NonTerminal.flatten( self, 'strcontents', 'strcontent' )


class StrContent( NonTerminal ):
    """class to handle `strcontent` grammar."""

    def __init__( self, parser, term, nonterm ) :
        NonTerminal.__init__( self, parser, term, nonterm )
        self._terms = (self.TERMINAL,) = (term,)
        self._nonterms = (self.nonterm,) = (nonterm,)
        self._terms = filter( None, self._terms )
        self._nonterms = filter( None, self._nonterms )
        # Set parent attribute for children, should be last statement !!
        self.setparent( self, self.children() )

    def children( self ):
        return self._terms + self._nonterms

    def show( self, buf=sys.stdout, offset=0, attrnames=False,
              showcoord=False ):
        lead = ' ' * offset
        buf.write( lead + 'strcontent: ' )
        if showcoord:
            buf.write( ' (at %s)' % self.coord )
        buf.write('\n')
        [ x.show(buf, offset+2, attrnames, showcoord) for x in self.children() ]

#---- Style

class Style( NonTerminal ):
    """class to handle `style` grammar."""

    def __init__( self, parser, openbrace, stylecontents, closebrace ) :
        NonTerminal.__init__( self, parser, openbrace, stylecontents, closebrace )
        self._terms = self.OPENBRACE, self.CLOSEBRACE = openbrace, closebrace
        self._nonterms = (self.stylecontents,) = (stylecontents,)
        # Set parent attribute for children, should be last statement !!
        self.setparent( self, self.children() )

    def children( self ):
        return (self.OPENBRACE, self.stylecontents, self.CLOSEBRACE)

    def generate( self, igen, *args, **kwargs ):
        if self.stylecontents :
            self.stylecontents.generate( igen, *args, **kwargs )
        return None

    def show( self, buf=sys.stdout, offset=0, attrnames=False,
              showcoord=False ):
        lead = ' ' * offset
        buf.write( lead + 'style: ' )
        if showcoord:
            buf.write( ' (at %s)' % self.coord )
        buf.write('\n')
        [ x.show(buf, offset+2, attrnames, showcoord) for x in self.children() ]


class StyleContents( NonTerminal ):
    """class to handle `stylecontents` grammar."""

    def __init__( self, parser, stylecontents, stylecontent ) :
        NonTerminal.__init__( self, parser, stylecontents, stylecontent )
        self._nonterms = self.stylecontents, self.stylecontent = \
                stylecontents, stylecontent
        self._nonterms = filter( None, self._nonterms )
        # Set parent attribute for children, should be last statement !!
        self.setparent( self, self.children() )

    def children( self ):
        return self._nonterms

    def generate( self, igen, *args, **kwargs ):
        contents = self.flatten()
        #contents = filter( lambda x : not isinstance(x, NEWLINES), contents )
        text = ''
        for cont in contents :
            if cont.exprs:
                igen.puttext(text); cont.generate(igen, *args, **kwargs);
                text = ''
            else :
                text += cont.dump( Context() )
        text and igen.puttext(text)

    def show( self, buf=sys.stdout, offset=0, attrnames=False,
              showcoord=False ):
        lead = ' ' * offset
        buf.write( lead + 'stylecontents: ' )
        if showcoord:
            buf.write( ' (at %s)' % self.coord )
        buf.write('\n')
        [ x.show(buf, offset+2, attrnames, showcoord) for x in self.children() ]

    def flatten( self ) :
        return NonTerminal.flatten( self, 'stylecontents', 'stylecontent' )


class StyleContent( NonTerminal ):
    """class to handle `stylecontent` grammar."""

    def __init__( self, parser, newlines, s, text, exprs ) :
        # `text` can also be `specialchars`
        NonTerminal.__init__( self, parser, newlines, s, text, exprs )
        self._terms = self.NEWLINES, self.S, self.TEXT = newlines, s, text
        self._nonterms = (self.exprs,) = (exprs,)
        self._terms = filter( None, self._terms )
        self._nonterms = filter( None, self._nonterms )
        # Set parent attribute for children, should be last statement !!
        self.setparent( self, self.children() )

    def children( self ):
        return self._terms + self._nonterms

    def show( self, buf=sys.stdout, offset=0, attrnames=False,
              showcoord=False ):
        lead = ' ' * offset
        buf.write( lead + 'stylecontent: ' )
        if showcoord:
            buf.write( ' (at %s)' % self.coord )
        buf.write('\n')
        [ x.show(buf, offset+2, attrnames, showcoord) for x in self.children() ]


#---- Expression substitution


class Exprs( NonTerminal ):
    """class to handle `exprs` grammar."""

    def __init__( self, parser, openexprs, exprs_contents, closebrace ) :
        NonTerminal.__init__( self, parser, openexprs, exprs_contents, closebrace )
        self._terms = self.OPENEXPRS, self.CLOSEBRACE = openexprs, closebrace
        self._nonterms = (self.exprs_contents,) = (exprs_contents,)
        # Set parent attribute for children, should be last statement !!
        self.setparent( self, self.children() )

    def children( self ):
        return self.OPENEXPRS, self.exprs_contents, self.CLOSEBRACE

    def generate( self, igen, *args, **kwargs ):
        return self.exprs_contents.generate(igen, *args, **kwargs)

    def show( self, buf=sys.stdout, offset=0, attrnames=False,
              showcoord=False ):
        lead = ' ' * offset
        buf.write( lead + 'exprs: ' )
        if showcoord:
            buf.write( ' (at %s)' % self.coord )
        buf.write('\n')
        [ x.show(buf, offset+2, attrnames, showcoord) for x in self.children() ]


class ExprsContents( NonTerminal ):
    """class to handle `exprs_contents` grammar."""

    def __init__( self, parser, exprs_contents, exprs_content ) :
        NonTerminal.__init__( self, parser, exprs_contents, exprs_content )
        self._nonterms = self.exprs_contents, self.exprs_content = \
                exprs_contents, exprs_content
        self._nonterms = filter( None, self._nonterms )
        # Set parent attribute for children, should be last statement !!
        self.setparent( self, self.children() )

    def children( self ):
        return self._nonterms

    def generate( self, igen, *args, **kwargs ):
        contents = self.flatten()
        contents = filter( lambda x : not isinstance(x, NEWLINES), contents )
        text = ''.join([ x.dump( Context() ) for x in contents ])
        igen.evalexprs( text )
        return None

    def show( self, buf=sys.stdout, offset=0, attrnames=False,
              showcoord=False ):
        lead = ' ' * offset
        buf.write( lead + 'exprs_contents: ' )
        if showcoord:
            buf.write( ' (at %s)' % self.coord )
        buf.write('\n')
        [ x.show(buf, offset+2, attrnames, showcoord) for x in self.children() ]

    def flatten( self ) :
        return NonTerminal.flatten( self, 'exprs_contents', 'exprs_content' )


class ExprsContent( NonTerminal ):
    """class to handle `exprs_content` grammar."""

    def __init__( self, parser, newlines, s, string, text ) :
        # `text` can also be `specialchars`
        NonTerminal.__init__( self, parser, newlines, s, string, text )
        self._terms = self.NEWLINES, self.S, self.STRING, self.TEXT = \
                newlines, s, string, text
        self._terms = filter( None, self._terms )
        # Set parent attribute for children, should be last statement !!
        self.setparent( self, self.children() )

    def children( self ):
        return self._terms
    
    def show( self, buf=sys.stdout, offset=0, attrnames=False,
              showcoord=False ):
        lead = ' ' * offset
        buf.write( lead + 'exprs_content: ' )
        if showcoord:
            buf.write( ' (at %s)' % self.coord )
        buf.write('\n')
        [ x.show(buf, offset+2, attrnames, showcoord) for x in self.children() ]


class CommentLines( NonTerminal ):
    """class to handle `commentlines` grammar."""

    def __init__( self, parser, commentopen, commenttext, commentclose ) :
        NonTerminal.__init__(
            self, parser, commentopen, commenttext, commentclose )
        self._nonterms = self.commentopen, self.commenttext, self.commentclose=\
                commentopen, commenttext, commentclose
        self._nonterms = filter( None, self._nonterms )
        # Set parent attribute for children, should be last statement !!
        self.setparent( self, self.children() )

    def children( self ):
        return self._nonterms

    def show( self, buf=sys.stdout, offset=0, attrnames=False,
              showcoord=False ):
        lead = ' ' * offset
        buf.write( lead + 'commentline: ' )
        if showcoord:
            buf.write( ' (at %s)' % self.coord )
        buf.write('\n')
        [ x.show(buf, offset+2, attrnames, showcoord) for x in self.children() ]


class EmptyLines( NonTerminal ):
    """class to handle `emptylines` grammar."""

    def __init__( self, parser, emptylines, emptyspace ) :
        NonTerminal.__init__( self, parser, emptylines, emptyspace )
        self._terms = (self.EMPTYSPACE,) = (emptyspace,)
        self._nonterms = (self.emptylines,) = (emptylines,)
        self._nonterms = filter( None, self._nonterms )
        # Set parent attribute for children, should be last statement !!
        self.setparent( self, self.children() )

    def children( self ):
        return self._nonterms + self._terms

    def show( self, buf=sys.stdout, offset=0, attrnames=False,
              showcoord=False ):
        lead = ' ' * offset
        text = ''.join([ item.dump(None) for item in self.flatten() ])
        buf.write( lead + 'emptylines: %r' % text )
        if showcoord:
            buf.write( ' (at %s)' % self.coord )
        buf.write('\n')

    def flatten( self ):
        return NonTerminal.flatten( self, 'emptylines', lambda n : n._terms )


class WhiteSpace( NonTerminal ):
    """class to handle `whitespace` grammar."""

    def __init__( self, parser, whitespace, newlines, s ) :
        NonTerminal.__init__( self, parser, whitespace, newlines, s )
        self._terms = self.NEWLINES, self.S = newlines, s
        self._nonterms = (self.whitespace,) = (whitespace,)
        self._terms = filter( None, self._terms )
        self._nonterms = filter( None, self._nonterms )
        # Set parent attribute for children, should be last statement !!
        self.setparent( self, self.children() )

    def children( self ):
        return self._nonterms + self._terms

    def show( self, buf=sys.stdout, offset=0, attrnames=False,
              showcoord=False ):
        lead = ' ' * offset
        text = ''.join([ item.dump(None) for item in self.flatten() ])
        buf.write( lead + 'whitespace: %r' % text )
        if showcoord:
            buf.write( ' (at %s)' % self.coord )
        buf.write('\n')

    def flatten( self ):
        return NonTerminal.flatten( self, 'whitespace', lambda n : n._terms )


#-------------------------- AST Terminals -------------------------

#---- Whitespace terminals

class EMPTYSPACE( Terminal ) : pass
class INDENT( Terminal ) : pass
class DEDENT( Terminal ) : pass
class COMMENTOPEN( Terminal ) : pass
class COMMENTTEXT( Terminal ) : pass
class COMMENTCLOSE( Terminal ) : pass
class STATEMENT( Terminal ) : pass
class NEWLINES( Terminal ) : pass
class S( Terminal ) : pass

#---- directives

class DOCTYPE( Terminal ) : pass
class BODY( Terminal ) : pass
class IMPORTAS( Terminal ) : pass
class IMPLEMENT( Terminal ) : pass
class INHERIT( Terminal ) : pass
class USE( Terminal ) : pass
class FILTER( Terminal ) : pass
class FUNCTION( Terminal ) : pass
class INTERFACE( Terminal ) : pass

#---- Control terminals

class IF( Terminal ) : pass
class ELIF( Terminal ) : pass
class ELSE( Terminal ) : pass
class FOR( Terminal ) : pass
class WHILE( Terminal ) : pass

#---- Text

class STRING( Terminal ) : pass
class ATOM( Terminal ) : pass
class TEXT( Terminal ) : pass
class SPECIALCHARS( Terminal ) : pass

#---- Markup

class TAGOPEN( Terminal ) : pass
class TAGEND( Terminal ) : pass
class TAGCLOSE( Terminal ) : pass
class OPENEXPRS( Terminal ) : pass
class EQUAL( Terminal ) : pass
class SQUOTE( Terminal ) : pass
class DQUOTE( Terminal ) : pass
class OPENBRACE( Terminal ) : pass
class CLOSEBRACE( Terminal ) : pass
